# ctctl<a name="ZH-CN_TOPIC_0000001788637360"></a>





## ctctl help<a name="ZH-CN_TOPIC_0000001835276893"></a>

**命令功能<a name="zh-cn_topic_0000001788626096_section39926938"></a>**

**ctctl help**命令用于查询CLI框架当前支持的所有命令的名称、描述和用法。

**命令格式<a name="zh-cn_topic_0000001788626096_section23798129"></a>**

**ctctl help**

**参数说明<a name="zh-cn_topic_0000001788626096_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788626096_section1393162518177"></a>**

无。

**使用示例<a name="zh-cn_topic_0000001788626096_section63268730"></a>**

查询CLI框架当前支持的所有命令的名称、描述和用法。

```
[root@rto0-node0 ~]# ctctl help
The commands we support are as follows:
[commands]               	[description]            
help                     	executable command query: ctctl help
log query                	audit log query: this_command [format=json/table]
collection logs          	get logs of all modules as tar.gz: this_command [log_dir=/your_path] [type=recent/all]. example: ctctl collection logs log_dir=/root/log_saves/ type=all
logs progress query      	query the progress of log collection: this_command [format=json/table]
```

**输出说明<a name="zh-cn_topic_0000001788626096_section1412117293556"></a>**

无。

## ctctl log query<a name="ZH-CN_TOPIC_0000001788477716"></a>

**命令功能<a name="zh-cn_topic_0000001835265713_section39926938"></a>**

**ctctl log query**命令用于查询审计日志。支持查询CLI命令执行者的进程IP（pid），用户ID（uid），具体执行了哪条CLI命令，该条CLI命令执行的状态，以及该条CLI命令执行开始的时间。

**命令格式<a name="zh-cn_topic_0000001835265713_section1910114921215"></a>**

**ctctl log query**  \[format=_?_  \]

**参数说明<a name="zh-cn_topic_0000001835265713_section6395528141419"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|format=?|用于指定终端显示审计日志结果的展示格式。|取值为json或table。默认值为json。当取值为json时，将会以字符串的形式在终端展示查询的结果。当取值为table时，将会以表格的形式在终端展示查询的结果。|


**使用说明<a name="zh-cn_topic_0000001835265713_section1393162518177"></a>**

无。

**使用示例<a name="zh-cn_topic_0000001835265713_section155131536132112"></a>**

-   查询审计日志，不指定**format**参数值。

    ```
    [root@rto0-node0 ~]# ctctl log query
    {{"client_pid": "2809452", "client_uid": "6004", "command": "show cantian status", "running_status": "success", "begin_time": "2023-02-17 15:22:10"}, {"client_pid": "3256214", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:05:19"}, {"client_pid": "3278085", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:08:04"}, {"client_pid": "3280197", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:08:17"}, {"client_pid": "3294706", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:10:04"}, {"client_pid": "3303433", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:11:10"}, {"client_pid": "3337212", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:15:20"}, {"client_pid": "3347609", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:16:36"}, {"client_pid": "3365544", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:18:51"}, {"client_pid": "4164417", "client_uid": "6004", "command": "show cantian status", "running_status": "success", "begin_time": "2023-02-20 16:58:17"}, {"client_pid": "4165421", "client_uid": "6004", "command": "show cantian status", "running_status": "success", "begin_time": "2023-02-20 16:58:25"}, {"client_pid": "520274", "client_uid": "6004", "command": "log query", "running_status": "success", "begin_time": "2023-02-23 16:42:18"}}
    ```

-   查询审计日志，指定**format**参数值为“json“。

    ```
    [root@rto0-node0 ~]# ctctl log query format=json
    {{"client_pid": "2809452", "client_uid": "6004", "command": "show cantian status", "running_status": "success", "begin_time": "2023-02-17 15:22:10"}, {"client_pid": "3256214", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:05:19"}, {"client_pid": "3278085", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:08:04"}, {"client_pid": "3280197", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:08:17"}, {"client_pid": "3294706", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:10:04"}, {"client_pid": "3303433", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:11:10"}, {"client_pid": "3337212", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:15:20"}, {"client_pid": "3347609", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:16:36"}, {"client_pid": "3365544", "client_uid": "6004", "command": "collection logs", "running_status": "success", "begin_time": "2023-02-20 15:18:51"}, {"client_pid": "4164417", "client_uid": "6004", "command": "show cantian status", "running_status": "success", "begin_time": "2023-02-20 16:58:17"}, {"client_pid": "4165421", "client_uid": "6004", "command": "show cantian status", "running_status": "success", "begin_time": "2023-02-20 16:58:25"}, {"client_pid": "520274", "client_uid": "6004", "command": "log query", "running_status": "success", "begin_time": "2023-02-23 16:42:18"}, {"client_pid": "557310", "client_uid": "6004", "command": "log query", "running_status": "success", "begin_time": "2023-02-23 16:45:30"}}
    ```

-   查询审计日志，指定**format**参数值为“table“。

    ```
    [root@rto0-node0 ~]# ctctl log query format=table
    +-------------+-------------+----------------------+-----------------+----------------------+
    | client_pid  | client_uid  |       command        | running_status  |      begin_time      |
    +-------------+-------------+----------------------+-----------------+----------------------+
    |  2809452    |    6004     | show cantian status  |    success      | 2023-02-17 15:22:10  |
    |  3256214    |    6004     |   collection logs    |    success      | 2023-02-20 15:05:19  |
    |  3278085    |    6004     |   collection logs    |    success      | 2023-02-20 15:08:04  |
    |  3280197    |    6004     |   collection logs    |    success      | 2023-02-20 15:08:17  |
    |  3294706    |    6004     |   collection logs    |    success      | 2023-02-20 15:10:04  |
    |  3303433    |    6004     |   collection logs    |    success      | 2023-02-20 15:11:10  |
    |  3337212    |    6004     |   collection logs    |    success      | 2023-02-20 15:15:20  |
    |  3347609    |    6004     |   collection logs    |    success      | 2023-02-20 15:16:36  |
    |  3365544    |    6004     |   collection logs    |    success      | 2023-02-20 15:18:51  |
    |  4164417    |    6004     | show cantian status  |    success      | 2023-02-20 16:58:17  |
    |  4165421    |    6004     | show cantian status  |    success      | 2023-02-20 16:58:25  |
    |   520274    |    6004     |      log query       |    success      | 2023-02-23 16:42:18  |
    |   557310    |    6004     |      log query       |    success      | 2023-02-23 16:45:30  |
    |   573670    |    6004     |      log query       |    success      | 2023-02-23 16:46:42  |
    +-------------+-------------+----------------------+-----------------+----------------------+
    ```

**输出说明<a name="zh-cn_topic_0000001835265713_section1412117293556"></a>**

无。

## ctctl collection logs<a name="ZH-CN_TOPIC_0000001835236949"></a>

**命令功能<a name="zh-cn_topic_0000001788626220_section39926938"></a>**

**ctctl collection logs**命令用于一键式信息收集。

**命令格式<a name="zh-cn_topic_0000001788626220_section1910114921215"></a>**

**ctctl collection logs**  log\_dir=_?_  type=_?_

**参数说明<a name="zh-cn_topic_0000001788626220_section6395528141419"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|log_dir=?|必选参数，信息收集之后，该位置用于存放压缩包的目录。|以/开头，支持数字、大小写英文字符、_、-以及~等符合Linux目录规范的路径名。路径必须在/opt/cantian目录下并确保ctmgruser用户有权限创建该路径。以/opt/cantian/ct_om/logs_packing为例，执行**chown ctmgruser:ctmgruser /opt/cantian/ct_om/logs_packing**命令修改存放信息目录的权限。|
|type=?|必选参数，表示信息收集范围。|all和recent二选一。all：全量信息收集，即所有模块现有信息全部收集。recent：仅采集各模块近期生成的信息。信息收集模块配置表中的size字段用于限制收集近期信息的量，比如size值为30，则采集该模块最近30兆字节的信息。|


**使用说明<a name="zh-cn_topic_0000001788626220_section1393162518177"></a>**

无。

**使用示例<a name="zh-cn_topic_0000001788626220_section155131536132112"></a>**

-   执行一键式信息收集，指定信息收集完毕后存放目录为“/opt/cantian/ct\_om/logs\_packing“，指定信息收集范围为全量信息收集。

    ```
    [root@rto0-node0 ~]# ctctl collection logs log_dir=/opt/cantian/ct_om/logs_packing type=all
    start log collection successful, use [ctctl logs progress query] to get current collection progress
    ```

-   执行一键式信息收集，指定信息收集完毕后存放目录为“/opt/cantian/ct\_om/logs\_packing“，指定信息收集范围为近期信息收集。

    ```
    [root@rto0-node0 ~]# ctctl collection logs log_dir=/opt/cantian/ct_om/logs_packing type=recent
    start log collection successful, use [ctctl logs progress query] to get current collection progress
    ```

**输出说明<a name="zh-cn_topic_0000001788626220_section1412117293556"></a>**

无。

## ctctl logs progress query<a name="ZH-CN_TOPIC_0000001788637364"></a>

**命令功能<a name="zh-cn_topic_0000001788626248_section39926938"></a>**

**ctctl logs progress query**命令用于一键式查询信息收集进度。

**命令格式<a name="zh-cn_topic_0000001788626248_section1910114921215"></a>**

**ctctl logs progress query**  \[ format=? \]

**参数说明<a name="zh-cn_topic_0000001788626248_section6395528141419"></a>**

|参数|说明|取值|
|--|--|--|
|format=?|用于指定终端显示日志结果的展示格式。|取值为json或table。默认值为json。当取值为json时，将会以字符串的形式在终端展示查询的结果。当取值为table时，将会以表格的形式在终端展示查询的结果。|


**使用说明<a name="zh-cn_topic_0000001788626248_section1393162518177"></a>**

无。

**使用示例<a name="zh-cn_topic_0000001788626248_section155131536132112"></a>**

-   执行一键式信息收集进度查询，不指定**format**参数值。

    ```
    [root@rto0-node0 ~]# ctctl logs progress query
    [{'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'om_deploy.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '6.25%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'deploy.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '12.50%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'exporter.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '18.75%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'ctmgr_', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '25.00%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'install.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '31.25%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'uninstall.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '37.50%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'backup.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '43.75%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'update.log', 'generate_type': 'task generated', 'status': 'fail', 'err_type': 'source log file missing', 'percentage': '50.00%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'dsware_cantiand', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '56.25%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'cantian_install.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '62.50%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:41', 'module_name': 'cantiand.rlog', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '68.75%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:41', 'module_name': 'cantianstatus.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '75.00%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:41', 'module_name': 'cms_deploy.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '81.25%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:41', 'module_name': 'CmsStatus.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '87.50%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:51', 'module_name': 'cms_srv', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '93.75%'}, {'start_time': '2023-02-23 16:56:51', 'end_time': '2023-02-23 16:56:57', 'module_name': 'cms_adm', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '100.00%'}]
    ```

-   执行一键式信息收集进度查询，指定**format**参数值为“json“。

    ```
    [root@rto0-node0 ~]# ctctl logs progress query format=json
    [{'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'om_deploy.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '6.25%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'deploy.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '12.50%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'exporter.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '18.75%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'ctmgr_', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '25.00%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'install.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '31.25%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'uninstall.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '37.50%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'backup.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '43.75%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'update.log', 'generate_type': 'task generated', 'status': 'fail', 'err_type': 'source log file missing', 'percentage': '50.00%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'dsware_cantiand', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '56.25%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:28', 'module_name': 'cantian_install.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '62.50%'}, {'start_time': '2023-02-23 16:56:28', 'end_time': '2023-02-23 16:56:41', 'module_name': 'cantiand.rlog', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '68.75%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:41', 'module_name': 'cantianstatus.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '75.00%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:41', 'module_name': 'cms_deploy.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '81.25%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:41', 'module_name': 'CmsStatus.log', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '87.50%'}, {'start_time': '2023-02-23 16:56:41', 'end_time': '2023-02-23 16:56:51', 'module_name': 'cms_srv', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '93.75%'}, {'start_time': '2023-02-23 16:56:51', 'end_time': '2023-02-23 16:56:57', 'module_name': 'cms_adm', 'generate_type': 'task generated', 'status': 'done', 'err_type': 'None', 'percentage': '100.00%'}]
    ```

-   执行一键式信息收集进度查询，指定**format**参数值为“table“。

    ```
    [root@rto0-node0 ~]# ctctl logs progress query format=table
    +----------------------+----------------------+----------------------+-----------------+---------+--------------------------+-------------+
    |      start_time      |       end_time       |     module_name      | generate_type   | status  |         err_type         | percentage  |
    +----------------------+----------------------+----------------------+-----------------+---------+--------------------------+-------------+
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |    om_deploy.log     | task generated  |  done   |           None           |   6.25%     |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |      deploy.log      | task generated  |  done   |           None           |   12.50%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |     exporter.log     | task generated  |  done   |           None           |   18.75%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |        ctmgr_        | task generated  |  done   |           None           |   25.00%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |     install.log      | task generated  |  done   |           None           |   31.25%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |    uninstall.log     | task generated  |  done   |           None           |   37.50%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |      backup.log      | task generated  |  done   |           None           |   43.75%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |      update.log      | task generated  |  fail   | source log file missing  |   50.00%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  |   dsware_cantiand    | task generated  |  done   |           None           |   56.25%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:28  | cantian_install.log  | task generated  |  done   |           None           |   62.50%    |
    | 2023-02-23 16:56:28  | 2023-02-23 16:56:41  |    cantiand.rlog     | task generated  |  done   |           None           |   68.75%    |
    | 2023-02-23 16:56:41  | 2023-02-23 16:56:41  |  cantianstatus.log   | task generated  |  done   |           None           |   75.00%    |
    | 2023-02-23 16:56:41  | 2023-02-23 16:56:41  |    cms_deploy.log    | task generated  |  done   |           None           |   81.25%    |
    | 2023-02-23 16:56:41  | 2023-02-23 16:56:41  |    CmsStatus.log     | task generated  |  done   |           None           |   87.50%    |
    | 2023-02-23 16:56:41  | 2023-02-23 16:56:51  |       cms_srv        | task generated  |  done   |           None           |   93.75%    |
    | 2023-02-23 16:56:51  | 2023-02-23 16:56:57  |       cms_adm        | task generated  |  done   |           None           |  100.00%    |
    +----------------------+----------------------+----------------------+-----------------+---------+--------------------------+-------------+
    ```

**输出说明<a name="zh-cn_topic_0000001788626248_section1412117293556"></a>**

无。

# cms<a name="ZH-CN_TOPIC_0000001835276897"></a>

































## cms server -start<a name="ZH-CN_TOPIC_0000001788477720"></a>

**命令功能<a name="zh-cn_topic_0000001835265761_section39926938"></a>**

**cms server -start**命令用于启动CMS。

**命令格式<a name="zh-cn_topic_0000001835265761_section23798129"></a>**

**cms server -start**

**参数说明<a name="zh-cn_topic_0000001835265761_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835265761_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265761_section63268730"></a>**

启动cms。

```
$ cms server -start
NODE_ID     = 0
CMS_HOME    = /opt/cantian/cms
GCC_HOME    = /mnt/dbdata/remote/share_share_fs7173/gcc_home/gcc_file
GCC_TYPE    = FILE
VERSION     = Cantian xxx
cms startup...
MES: LSNR 192.168.86.1:14587
mes connect to channel peer 192.168.86.2:14587, success
```

**输出说明<a name="zh-cn_topic_0000001835265761_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字段|含义|
|--|--|
|NODE ID|节点ID。|
|CMS_HOME|CMS相关数据存放的位置。|
|GCC_HOME|存放CMS持久化数据的位置。|
|GCC_TYPE|GCC持久化数据的存放格式。|
|VERSION|当前版本信息。|


## cms server -stop<a name="ZH-CN_TOPIC_0000001835236953"></a>

**命令功能<a name="zh-cn_topic_0000001788466528_section39926938"></a>**

**cms server -stop**命令用于停止CMS。

**命令格式<a name="zh-cn_topic_0000001788466528_section23798129"></a>**

**cms server -stop**

**参数说明<a name="zh-cn_topic_0000001788466528_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788466528_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466528_section63268730"></a>**

停止cms。

```
$ cms server -stop
stop cms server succeed.
```

**输出说明<a name="zh-cn_topic_0000001788466528_section1412117293556"></a>**

无。

## cms stat<a name="ZH-CN_TOPIC_0000001788637368"></a>

**命令功能<a name="zh-cn_topic_0000001835225825_section39926938"></a>**

**cms stat**命令用于查看集群状态。

**命令格式<a name="zh-cn_topic_0000001835225825_section23798129"></a>**

**cms stat**

**参数说明<a name="zh-cn_topic_0000001835225825_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835225825_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225825_section63268730"></a>**

查看集群状态。

```
$ cms stat
NODE_ID  NAME      STAT    PRE_STAT    TARGET_STAT   WORK_STAT         
0          db        ONLINE   UNKNOWN     ONLINE                1
1          db        ONLINE   OFFLINE     ONLINE                1
SESSION_ID   INSTANCE_ID   ROLE         LAST_CHECK
0             0               REFORMER   2022-12-27 15:39:27.660
0             1                          2022-12-27 15:39:29.084
HB_TIME               STAT_CHANGE
2022-12-27 15:39:27.660   2022-12-27 15:34:21.875
2022-12-27 15:39:29.084   2022-12-27 15:38:51.235
```

**输出说明<a name="zh-cn_topic_0000001835225825_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|NODE_ID|节点ID。|
|NAME|Cantian引擎名称。|
|STAT|Cantian引擎的状态，分为：ONLINE：在线OFFLINE：离线UNKNOWN：状态未知|
|PRE_STAT|Cantian引擎的上一个状态。|
|TARGET_STAT|Cantian引擎的下一个目标状态。|
|WORK_STAT|Cantian引擎的工作状态，分为：RC_JOINING (0) ：正在加入集群RC_JOINED (1) ：已经加入集群RC_LEAVING (2) ：正在离开集群RC_LEFT (3) ：已经离开集群|
|SESSION_ID|Cantian引擎的ID。目前只有一个资源，因此ID为0，当资源离线时，为-1。|
|INSTANCE_ID|Cantian引擎的实例ID。目前只有一个资源，因此节点ID相同，当资源离线时，为-1。|
|ROLE|Cantian引擎的角色，包括reformer和非reformer两种角色，一类资源在一个集群中有且仅会存在1个reformer。|
|LAST_CHECK|上一次检查Cantian引擎的时间，等于HB_TIME，当Cantian引擎离线时时间为2000-01-01 00:00:00.000。|
|HB_TIME|上一次收到Cantian引擎心跳消息的时间，当Cantian引擎离线时时间为2000-01-01 00:00:00.000。|
|STAT_CHANGE|上一次Cantian引擎状态变化的时间。|


## cms stat -node<a name="ZH-CN_TOPIC_0000001835276901"></a>

**命令功能<a name="zh-cn_topic_0000001788626140_section39926938"></a>**

**cms stat -node**命令用于查看节点状态。

**命令格式<a name="zh-cn_topic_0000001788626140_section23798129"></a>**

-   **cms stat -node**
-   **cms stat -node** _NODE ID_

**参数说明<a name="zh-cn_topic_0000001788626140_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|NODE ID|节点ID。|-|


**使用说明<a name="zh-cn_topic_0000001788626140_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626140_section63268730"></a>**

-   查看所有节点状态。

    ```
    $ cms stat -node
    NODE_ID   NODE_NAME       ROLE
    0     node0              server
    1     node1              agent
    ```

-   查看指定节点状态。

    ```
    $ cms stat -node 0
    NODE_ID   NODE_NAME       ROLE
    0     node0              server
    ```

**输出说明<a name="zh-cn_topic_0000001788626140_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|NODE_ID|节点ID。|
|NODE_NAME|节点名称。|
|ROLE|节点的类型：当节点CMS为Master时，该节点类型为server，CMS Master负责控制脑裂仲裁等流程。当节点CMS为非Master时，该节点类型为agent。|


## cms stat -res<a name="ZH-CN_TOPIC_0000001788477724"></a>

**命令功能<a name="zh-cn_topic_0000001835265745_section39926938"></a>**

**cms stat -res**命令用于查看资源状态。

**命令格式<a name="zh-cn_topic_0000001835265745_section23798129"></a>**

-   **cms stat -res**
-   **cms stat -res** _RESOURCE NAME_

**参数说明<a name="zh-cn_topic_0000001835265745_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE NAME|资源名称，当前仅有db一种资源。|-|


**使用说明<a name="zh-cn_topic_0000001835265745_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265745_section63268730"></a>**

-   查看所有资源状态。

    ```
    $ cms stat -res
    NODE_ID  RESOURCE_NAME  STAT   PRE_STAT  TARGET_STAT  WORK_STAT                      
    0           db                ONLINE  UNKNOWN  ONLINE        1
    1           db                ONLINE  OFFLINE  ONLINE        1
    LAST_CHECK            STAT_CHANGE
    2022-12-27 15:42:23.682    2022-12-27 15:34:21.875
    2022-12-27 15:42:23.106    2022-12-27 15:38:51.235
    ```

-   查看指定资源状态。

    ```
    $ cms stat -res db
    NODE_ID  RESOURCE_NAME  STAT   PRE_STAT  TARGET_STAT  WORK_STAT
    0           db                ONLINE  UNKNOWN  ONLINE        1
    1           db                ONLINE  OFFLINE  ONLINE        1
    LAST_CHECK            STAT_CHANGE
    2022-12-27 15:42:50.185    2022-12-27 15:34:21.875
    2022-12-27 15:42:49.610    2022-12-27 15:38:51.235
    ```

**输出说明<a name="zh-cn_topic_0000001835265745_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|NODE_ID|节点ID。|
|RESOURCE_NAME|资源名称，当前仅有db一种资源。|
|STAT|资源的状态，分为：ONLINE：在线OFFLINE：离线UNKNOWN：状态未知|
|PRE_STAT|资源的上一个状态。|
|TARGET_STAT|资源的下一个目标状态。|
|WORK_STAT|资源的工作状态，分为：RC_JOINING (0) ：正在加入集群RC_JOINED (1) ：已经加入集群RC_LEAVING (2) ：正在离开集群RC_LEFT (3) ：已经离开集群|
|LAST_CHECK|上一次检查资源的时间，等于HB_TIME，当资源离线时时间为2000-01-01 00:00:00.000。|
|STAT_CHANGE|上一次资源状态变化的时间。|


## cms stat -server<a name="ZH-CN_TOPIC_0000001835236961"></a>

**命令功能<a name="zh-cn_topic_0000001788626228_section39926938"></a>**

**cms stat -server**命令用于查看CMS状态。

**命令格式<a name="zh-cn_topic_0000001788626228_section23798129"></a>**

-   **cms stat -server**
-   **cms stat -server** _NODE ID_

**参数说明<a name="zh-cn_topic_0000001788626228_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|NODE ID|节点ID|-|


**使用说明<a name="zh-cn_topic_0000001788626228_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626228_section63268730"></a>**

-   查看所有CMS状态。

    ```
    $ cms stat -server
    NODE_ID  SRV_READY  SEND_QUE  RECV_QUE  TIME_GAP(ms)
    0          TRUE         0           0           0
    1          TRUE         0           0           1
    ```

-   查看指定节点CMS状态。

    ```
    $ cms stat -server 0
    NODE_ID  SRV_READY   SEND_QUE  RECV_QUE  TIME_GAP(ms)
    0          TRUE          0           0           0
    ```

**输出说明<a name="zh-cn_topic_0000001788626228_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|NODE ID|节点ID。|
|SRV_READY|节点CMS的工作状态：TRUE：表示CMS正常工作。FALSE：表示CMS为暂停工作。|
|SEND_QUE|CMS消息发送队列中消息的数目。|
|RECV_QUE|CMS消息接收队列中消息的数据。|
|TIME_GAP|该节点CMS与其他各节点CMS之间的时间跳变的最大值。|


## cms iostat<a name="ZH-CN_TOPIC_0000001788637372"></a>

**命令功能<a name="zh-cn_topic_0000001788626212_section39926938"></a>**

**cms iostat**命令用于获取CMS和Cantian引擎之间的消息处理统计信息。

**命令格式<a name="zh-cn_topic_0000001788626212_section23798129"></a>**

**cms iostat**

**参数说明<a name="zh-cn_topic_0000001788626212_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788626212_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626212_section63268730"></a>**

获取消息处理统计信息。

```
$ cms iostat
MSG_TYPE                                MSG_ALL  BACK_GOOD  BACK_BAD      AVG_US             MAX_US          MIN_US          TOTAL_US
CMS_CLI_MSG_REQ_GET_RES_STAT         1784          1784          0             964                   234567                410                   1720432
CMS_CLI_MSG_REQ_SET_RES_DATA         15            15            0             5428                  11038                 3907                  81420
CMS_CLI_MSG_REQ_GET_RES_DATA         889           889           0             4151                  1000937               1815                  3690934
CMS_CLI_MSG_REQ_HB                   889           888           0             64                    142                   51                    57023
CMS_CLI_MSG_RES_IOF_KICK             0             0             0             0                     0                     -1                    0
CMS_CLI_MSG_REQ_DIS_CONN             0             0             0             0                     0                     -1                    0
CMS_CLI_MSG_REQ_SET_WORK_STAT        2             2             0             5661                  6144                  5179                  11323
CMS_STATISTIC_TRY_BE_MASTER          1879          1879          0             9027                  8860580               1250                  16961835
CMS_STATISTIC_DETECT_DISK            1876          1876          0             9088                  8966337               1154                  17050794
CMS_STATISTIC_HB_AYNC_TIME_GAP       888           888           0             3569                  941295                897                   3169515
```

**输出说明<a name="zh-cn_topic_0000001788626212_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|MSG_TYPE|消息类型，包括：CMS_CLI_MSG_REQ_GET_RES_STAT：CMS获取资源状态的请求消息CMS_CLI_MSG_REQ_SET_RES_DATA：CMS设置资源数据的请求消息CMS_CLI_MSG_REQ_GET_RES_DATA：CMS获取资源数据的请求消息CMS_CLI_MSG_REQ_HB：CMS与Cantian引擎之间的心跳请求消息CMS_CLI_MSG_RES_IOF_KICK：Cantian引擎处理Iofence的结果消息CMS_CLI_MSG_REQ_DIS_CONN：CMS与Cantian引擎断开uds连接的请求消息CMS_CLI_MSG_REQ_SET_WORK_STAT：CMS设置资源工作状态的请求消息CMS_STATISTIC_TRY_BE_MASTER：统计CMS争取成为Master次数的消息CMS_STATISTIC_DETECT_DISK：统计CMS读取磁盘次数的消息CMS_STATISTIC_HB_AYNC_TIME_GAP：接收到心跳和心跳落盘的时间差|
|MSG_ALL|总共的消息数量。|
|BACK_GOOD|处理成功的消息数量。|
|BACK_BAD|处理失败的消息数量。|
|AVG_US|处理消息的平均时延。|
|MAX_US|处理消息的最大时延。|
|MIN_US|处理消息的最小时延。|
|TOTAL_US|处理消息的总时延。|


## cms iostat -reset<a name="ZH-CN_TOPIC_0000001835276905"></a>

**命令功能<a name="zh-cn_topic_0000001788626172_section39926938"></a>**

**cms iostat -reset**命令用于将CMS和Cantian引擎之间的消息处理统计信息清零。

**命令格式<a name="zh-cn_topic_0000001788626172_section23798129"></a>**

**cms iostat -reset**

**参数说明<a name="zh-cn_topic_0000001788626172_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788626172_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626172_section63268730"></a>**

消息处理统计信息清零。

```
$ cms iostat -reset
reset cms iostat success.
```

**输出说明<a name="zh-cn_topic_0000001788626172_section1412117293556"></a>**

无。

## cms res -list<a name="ZH-CN_TOPIC_0000001788477728"></a>

**命令功能<a name="zh-cn_topic_0000001835225681_section39926938"></a>**

**cms res -list**命令用于列出资源在gcc\_file中记录的参数和配置信息。

**命令格式<a name="zh-cn_topic_0000001835225681_section23798129"></a>**

**cms res -list**

**参数说明<a name="zh-cn_topic_0000001835225681_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835225681_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225681_section63268730"></a>**

列出资源在gcc\_file中记录的参数和配置信息。

```
$ cms res -list
RESOURCE_NAME    RESOURCE_TYPE    RESOURCE_GROUP_NAME     START_TIMEOUT(ms)
db                   db                   default                        1000
STOP_TIMEOUT(ms)    CHECK_TIMEOUT(ms)   CHECK_INTERVAL(ms)  HB_TIMEOUT(ms)
1000                  1000                    1000                    10000
RESTART_TIMES       RESTART_INTERVAL    SCRIPT
0                      45000                   /opt/cantian/cms/service/bin/cluster.sh
```

**输出说明<a name="zh-cn_topic_0000001835225681_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字段名称|含义|
|--|--|
|RESOURCE_NAME|资源名称，当前仅有db一种资源。|
|RESOURCE_TYPE|资源类型。|
|RESOURCE_GROUP_NAME|预留，当前版本暂不启用。|
|START_TIMEOUT(ms)|预留，当前版本暂不启用。|
|STOP_TIMEOUT(ms)|预留，当前版本暂不启用。|
|CHECK_TIMEOUT(ms)|预留，当前版本暂不启用。|
|CHECK_INTERVAL(ms)|预留，当前版本暂不启用。|
|HB_TIMEOUT(ms)|节点内资源与CMS的心跳异常阈值，在这个阈值时间内资源未成功向CMS发送过心跳信息，则CMS会下线资源，将其状态置为OFFLINE。|
|RESTART_TIMES|CMS主动重启资源的次数。例如当资源因某些异常原因退出，CMS会尝试主动重启资源。|
|RESTART_INTERVAL|重启资源间隔时间。例如当资源退出后，CMS尝试开始重启，当启动未成功时，间隔RESTART_INTERVAL后会再次尝试重启。|
|SCRIPT|CMS运行时调用的脚本。例如CMS启动资源时会调用该脚本。|


## cms res -edit<a name="ZH-CN_TOPIC_0000001835236965"></a>

**命令功能<a name="zh-cn_topic_0000001788626244_section39926938"></a>**

**cms res -edit**命令用于修改gcc\_file中资源的参数和配置。

**命令格式<a name="zh-cn_topic_0000001788626244_section23798129"></a>**

**cms res -edit** _RESOURCE NAME_ **-attr** _ATTRIBUTE PAIRS_

**参数说明<a name="zh-cn_topic_0000001788626244_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE NAME|资源名称。|-|
|ATTRIBUTE PAIRS|资源的属性。|属性列表参见cms res -list的各项字段。|


**使用说明<a name="zh-cn_topic_0000001788626244_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626244_section63268730"></a>**

修改gcc\_file中资源的参数和配置。

```
$ cms res -edit db -attr CHECK_TIMEOUT=1000000000
modify resource succeed.
```

**输出说明<a name="zh-cn_topic_0000001788626244_section1412117293556"></a>**

无。

## cms res -start<a name="ZH-CN_TOPIC_0000001788637376"></a>

**命令功能<a name="zh-cn_topic_0000001835225705_section39926938"></a>**

**cms res -start**命令用于启动集群内的资源。

**命令格式<a name="zh-cn_topic_0000001835225705_section23798129"></a>**

-   **cms res -start** _RESOURCE NAME_
-   **cms res -start** _RESOURCE NAME_ **-node** _NODE\_ID_
-   **cms res -start** _RESOURCE NAME_ _TIMEOUT_

**参数说明<a name="zh-cn_topic_0000001835225705_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE NAME|资源名称。|-|
|NODE_ID|节点ID。|-|
|TIMEOUT|启动超时阈值（启动时间超过阈值会返回，否则会等待）|-|


**使用说明<a name="zh-cn_topic_0000001835225705_section1140684110560"></a>**

-   执行该命令前，检查待启动节点的CMS server是否存活（执行**ps -ef|grep 'cms server'**命令查看是否存在cms server进程来判断）。
-   需要切换到cantian用户下执行。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >启动指定节点的资源，等待时间为600秒，600秒仍未成功启动，该命令超时报错退出。

**使用示例<a name="zh-cn_topic_0000001835225705_section63268730"></a>**

-   启动集群内所有资源。

    ```
    $ cms res -start db
    start resource succeed.
    ```

-   启动指定节点资源。

    ```
    $ cms res -start db -node 0
    start resource succeed.
    ```

-   指定等待时间启动集群内所有资源。

    ```
    $ cms res -start db 120000
    start resource succeed.
    ```

**输出说明<a name="zh-cn_topic_0000001835225705_section1412117293556"></a>**

无。

## cms res -stop<a name="ZH-CN_TOPIC_0000001835276909"></a>

**命令功能<a name="zh-cn_topic_0000001835225853_section39926938"></a>**

**cms res -stop**命令用于停止集群内的资源。

**命令格式<a name="zh-cn_topic_0000001835225853_section23798129"></a>**

-   **cms res -stop** _RESOURCE NAME_
-   **cms res -stop** _RESOURCE NAME_ **-node** _NODE\_ID_

**参数说明<a name="zh-cn_topic_0000001835225853_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE NAME|资源名称。|-|
|NODE_ID|节点ID。|-|


**使用说明<a name="zh-cn_topic_0000001835225853_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225853_section63268730"></a>**

-   停止集群内所有资源。

    ```
    $ cms res -stop db
    stop resource succeed.
    ```

-   停止指定节点资源。

    ```
    $ cms res -stop db -node 0
    stop resource succeed.
    ```

**输出说明<a name="zh-cn_topic_0000001835225853_section1412117293556"></a>**

无。

## cms res -add<a name="ZH-CN_TOPIC_0000001788477732"></a>

**命令功能<a name="zh-cn_topic_0000001835225769_section39926938"></a>**

**cms res -add**命令用于向CMS的gcc\_file中写入新的资源信息。

**命令格式<a name="zh-cn_topic_0000001835225769_section23798129"></a>**

-   **cms res -add** _RESOURCE NAME_ **-type** _RESOURCE TYPE_
-   **cms res -add** _RESOURCE NAME_ **-type** _RESOURCE TYPE_ **-attr**  "_ATTRIBUTE PAIRS_=_?_"

**参数说明<a name="zh-cn_topic_0000001835225769_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE NAME|资源名称。|-|
|RESOURCE TYPE|资源类型。|-|
|ATTRIBUTE PAIRS|资源的其他属性。|必须选择当前已有的属性，不区分大小写。属性列表参见cms res -list的各项字段。|


**使用说明<a name="zh-cn_topic_0000001835225769_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225769_section63268730"></a>**

-   向CMS的gcc\_file中写入名称为test\_name，类型为test\_type的资源信息。

    ```
    $ cms res -add test_name -type test_type
    add resource succeed.
    ```

-   向CMS的gcc\_file中写入名称为db\_test，类型为db\_test的资源信息，并指定脚本为test.sh。

    ```
    $ cms res -add db_test -type db_test -attr "script=test.sh"
    add resource succeed.
    ```

**输出说明<a name="zh-cn_topic_0000001835225769_section1412117293556"></a>**

无。

## cms res -del<a name="ZH-CN_TOPIC_0000001835236969"></a>

**命令功能<a name="zh-cn_topic_0000001788626208_section39926938"></a>**

**cms res -del**命令用于删除gcc\_file中指定资源的所有信息。

**命令格式<a name="zh-cn_topic_0000001788626208_section23798129"></a>**

**cms res -del** _RESOURCE NAME_

**参数说明<a name="zh-cn_topic_0000001788626208_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE NAME|资源名称。|-|


**使用说明<a name="zh-cn_topic_0000001788626208_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626208_section63268730"></a>**

删除gcc\_file中test\_name资源的所有信息。

```
$ cms res -del test_name
delete resource succeed.
```

**输出说明<a name="zh-cn_topic_0000001788626208_section1412117293556"></a>**

无。

## cms gcc -list<a name="ZH-CN_TOPIC_0000001788637380"></a>

**命令功能<a name="zh-cn_topic_0000001788466536_section39926938"></a>**

**cms gcc -list**命令用于查看gcc\_file的路径。

**命令格式<a name="zh-cn_topic_0000001788466536_section23798129"></a>**

**cms gcc -list**

**参数说明<a name="zh-cn_topic_0000001788466536_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788466536_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466536_section63268730"></a>**

查看gcc\_file的路径。

```
[cantian@k8snode0 run]$ cms gcc -list
gcc:/mnt/dbdata/remote/share_6971_share_fs/gcc_home/gcc_file
```

**输出说明<a name="zh-cn_topic_0000001788466536_section1412117293556"></a>**

无。

## cms gcc -reset<a name="ZH-CN_TOPIC_0000001835276913"></a>

**命令功能<a name="zh-cn_topic_0000001835225673_section39926938"></a>**

**cms gcc -reset**命令用于重置gcc\_file的静态数据信息。

**命令格式<a name="zh-cn_topic_0000001835225673_section23798129"></a>**

**cms gcc -reset**

**参数说明<a name="zh-cn_topic_0000001835225673_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835225673_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225673_section63268730"></a>**

重置gcc\_file的静态数据信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms gcc -reset
The operation will reset all data on gcc, are you sure?(y/n)
y
reset gcc succeed.
```

**输出说明<a name="zh-cn_topic_0000001835225673_section1412117293556"></a>**

无。

## cms gcc -reset -f<a name="ZH-CN_TOPIC_0000001788477736"></a>

**命令功能<a name="zh-cn_topic_0000001788466620_section39926938"></a>**

**cms gcc -reset -f**命令用于强制重置gcc\_file的静态数据信息。

**命令格式<a name="zh-cn_topic_0000001788466620_section23798129"></a>**

**cms gcc -reset -f**

**参数说明<a name="zh-cn_topic_0000001788466620_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788466620_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466620_section63268730"></a>**

强制重置gcc\_file的静态数据信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms gcc -reset -f
reset gcc succeed.
```

**输出说明<a name="zh-cn_topic_0000001788466620_section1412117293556"></a>**

无。

## cms gcc -exp<a name="ZH-CN_TOPIC_0000001835236973"></a>

**命令功能<a name="zh-cn_topic_0000001835225697_section39926938"></a>**

**cms gcc -exp**命令用于将gcc\_file静态数据信息导出到指定文件。

**命令格式<a name="zh-cn_topic_0000001835225697_section23798129"></a>**

**cms gcc -exp** _OUTPUT FILE PATH_

**参数说明<a name="zh-cn_topic_0000001835225697_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|OUTPUT FILE PATH|导出文件路径。导出路径需存在且cantian用户对该文件有读写权限。|-|


**使用说明<a name="zh-cn_topic_0000001835225697_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225697_section63268730"></a>**

将gcc\_file静态数据信息导出到指定文件。

```
[cantian@a12e76db3893 gcc_backup]$ cms gcc -exp /opt/cantian/cms/gcc_backup/gcc_exp
export gcc succeed.
```

**输出说明<a name="zh-cn_topic_0000001835225697_section1412117293556"></a>**

无。

## cms gcc -imp<a name="ZH-CN_TOPIC_0000001788637384"></a>

**命令功能<a name="zh-cn_topic_0000001788466524_section39926938"></a>**

**cms gcc -imp**命令用于将gcc\_file静态数据信息从指定格式化文件导入至存储系统。

**命令格式<a name="zh-cn_topic_0000001788466524_section23798129"></a>**

**cms gcc -imp** _INPUT FILE PATH_

**参数说明<a name="zh-cn_topic_0000001788466524_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|INPUT FILE PATH|导入文件路径。导入路径需存在可导入文件且cantian用户对该文件有读写权限。|-|


**使用说明<a name="zh-cn_topic_0000001788466524_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466524_section63268730"></a>**

将gcc\_file静态数据信息从指定格式化文件导入至存储系统。

```
[cantian@a12e76db3893 gcc_backup]$ cms gcc -imp /opt/cantian/cms/gcc_backup/gcc_exp
The operation will replace all data on gcc and can not rollback, are you sure?(y/n)
y
import gcc succeed.
```

**输出说明<a name="zh-cn_topic_0000001788466524_section1412117293556"></a>**

无。

## cms gcc -backup<a name="ZH-CN_TOPIC_0000001835276917"></a>

**命令功能<a name="zh-cn_topic_0000001835265573_section39926938"></a>**

**cms gcc -backup**命令用于备份当前gcc\_file的静态数据信息。

**命令格式<a name="zh-cn_topic_0000001835265573_section23798129"></a>**

**cms gcc -backup**

**参数说明<a name="zh-cn_topic_0000001835265573_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835265573_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265573_section63268730"></a>**

备份gcc\_file的静态数据信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms gcc -backup
backup gcc succeed.
[cantian@a12e76db3893 gcc_backup]$ ls
bak_20221227211546  bak_20221227211546.exp
```

**输出说明<a name="zh-cn_topic_0000001835265573_section1412117293556"></a>**

无。

## cms gcc -restore<a name="ZH-CN_TOPIC_0000001788477740"></a>

**命令功能<a name="zh-cn_topic_0000001835265737_section39926938"></a>**

**cms gcc -restore**命令用于将备份的gcc\_file静态数据恢复到存储系统。

**命令格式<a name="zh-cn_topic_0000001835265737_section23798129"></a>**

**cms gcc -restore** _BACKUP FILE PATH_

**参数说明<a name="zh-cn_topic_0000001835265737_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|BACKUP FILE PATH|备份文件所在路径。需存在可恢复文件且cantian用户对该文件有读写权限。|-|


**使用说明<a name="zh-cn_topic_0000001835265737_section1393162518177"></a>**

1.  需要切换到cantian用户下执行。
2.  需要先停止Cantian引擎。依次在所有节点执行以下命令停止Cantian引擎。

    其中，以Cantian引擎安装包的安装路径为/ctdb/cantian\_install为例说明。

    ```
    sh /ctdb/cantian_install/cantian_connector/action/appctl.sh stop
    ```

**使用示例<a name="zh-cn_topic_0000001835265737_section63268730"></a>**

将备份的gcc\_file静态数据恢复到存储系统。

```
[cantian@a12e76db3893 gcc_backup]$ cms gcc -restore /opt/cantian/cms/gcc_backup/bak_20221227211546
The operation will replace all data on gcc and can not rollback, are you sure?(y/n)
y
restore gcc succeed.
```

**输出说明<a name="zh-cn_topic_0000001835265737_section1412117293556"></a>**

无。

## cms node -add<a name="ZH-CN_TOPIC_0000001835236977"></a>

**命令功能<a name="zh-cn_topic_0000001835265701_section39926938"></a>**

**cms node -add**命令用于向CMS的gcc\_file中写入新的节点信息。

**命令格式<a name="zh-cn_topic_0000001835265701_section23798129"></a>**

-   **cms node -add** _NAME_ _IP_ _PORT_
-   **cms node -add** _NODE\_ID_ _NAME_ _IP_ _PORT_

**参数说明<a name="zh-cn_topic_0000001835265701_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|NAME|节点名称。|-|
|IP|节点IP。|-|
|PORT|端口。|-|
|NODE_ID|节点ID。|-|


**使用说明<a name="zh-cn_topic_0000001835265701_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265701_section63268730"></a>**

-   添加节点配置信息到gcc\_file，自动生成node\_id。

    ```
    [cantian@a12e76db3893 gcc_backup]$ cms node -add node0 192.168.86.1 14587
    add node succeed.
    ```

-   添加节点配置信息到gcc\_file，手动指定node\_id。

    ```
    [cantian@a12e76db3893 gcc_backup]$ cms node -add 0 node0 192.168.86.1 14587
    add node succeed.
    ```

**输出说明<a name="zh-cn_topic_0000001835265701_section1412117293556"></a>**

无。

## cms node -del<a name="ZH-CN_TOPIC_0000001788637388"></a>

**命令功能<a name="zh-cn_topic_0000001788626216_section39926938"></a>**

**cms node -del**命令用于删除节点信息。

**命令格式<a name="zh-cn_topic_0000001788626216_section23798129"></a>**

**cms node -del** _NODE\_ID_

**参数说明<a name="zh-cn_topic_0000001788626216_section12856577"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|NODE_ID|节点ID。|-|


**使用说明<a name="zh-cn_topic_0000001788626216_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626216_section63268730"></a>**

删除节点0的信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms node -del 0
delete node succeed.
```

**输出说明<a name="zh-cn_topic_0000001788626216_section1412117293556"></a>**

无。

## cms node -list<a name="ZH-CN_TOPIC_0000001835276921"></a>

**命令功能<a name="zh-cn_topic_0000001835225781_section39926938"></a>**

**cms node -list**命令用于查看集群所有节点的配置信息。

**命令格式<a name="zh-cn_topic_0000001835225781_section23798129"></a>**

**cms node -list**

**参数说明<a name="zh-cn_topic_0000001835225781_section12856577"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835225781_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225781_section63268730"></a>**

查看集群所有节点的配置信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms node -list
NODE_ID     NODE NAME            IP                PORT
0           node0                192.168.86.1      14587
1           node1                192.168.86.2      14587
```

**输出说明<a name="zh-cn_topic_0000001835225781_section1412117293556"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|NODE_ID|节点ID。|
|NODE NAME|节点名称。|
|IP|节点IP地址。|
|PORT|端口。|


## cms node -connected<a name="ZH-CN_TOPIC_0000001788477744"></a>

**命令功能<a name="zh-cn_topic_0000001835225813_section1467151510217"></a>**

**cms node -connected**命令用于查询集群中所有存活的节点。

**命令格式<a name="zh-cn_topic_0000001835225813_section1367171512110"></a>**

**cms node -connected**

**参数说明<a name="zh-cn_topic_0000001835225813_section667120156215"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835225813_section5671141514211"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225813_section8875169162517"></a>**

查询集群所有存活节点的信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms node -connected
NODE_ID     NODE_NAME             IP                                      PORT        VOTING
      0     node0                 192.168.86.1                            14587       FALSE
      1     node1                 192.168.86.2                            14587       FALSE
```

**输出说明<a name="zh-cn_topic_0000001835225813_section621214555243"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|NODE_ID|节点ID。|
|NODE NAME|节点名称。|
|IP|节点IP地址。|
|PORT|端口。|
|VOTING|节点是否正处于投票状态。|


## cms resgrp -list<a name="ZH-CN_TOPIC_0000001835236981"></a>

**命令功能<a name="zh-cn_topic_0000001835265705_section25971691516"></a>**

**cms resgrp -list**命令用于列出在gcc\_file中记录的资源组名称。

**命令格式<a name="zh-cn_topic_0000001835265705_section959116111520"></a>**

**cms resgrp -list**

**参数说明<a name="zh-cn_topic_0000001835265705_section135921681511"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001835265705_section85919162156"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265705_section359141611153"></a>**

查看在gcc\_file中记录的资源组名称。

```
[cantian@a12e76db3893 gcc_backup]$ cms resgrp -list
RESOURCE_GROUP
default
```

**输出说明<a name="zh-cn_topic_0000001835265705_section1060616181519"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|RESOURCE_GROUP|gcc中记录的资源组名称。|


## cms resgrp -add<a name="ZH-CN_TOPIC_0000001788637392"></a>

**命令功能<a name="zh-cn_topic_0000001788626200_section17993291240"></a>**

**cms resgrp -add**命令用于向集群中添加一个资源组。

**命令格式<a name="zh-cn_topic_0000001788626200_section179937912411"></a>**

**cms resgrp -add** _RESOURCE GROUP NAME_

**参数说明<a name="zh-cn_topic_0000001788626200_section109931494247"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE GROUP NAME|添加的资源组名称。|-|


**使用说明<a name="zh-cn_topic_0000001788626200_section189931698248"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626200_section1599319172411"></a>**

向集群中添加一个资源组。

```
[cantian@a12e76db3893 gcc_backup]$ cms resgrp -add GRP_0001
add resource group succeed.
```

**输出说明<a name="zh-cn_topic_0000001788626200_section999318972411"></a>**

无。

## cms resgrp -del<a name="ZH-CN_TOPIC_0000001835276925"></a>

**命令功能<a name="zh-cn_topic_0000001788466568_section138339216334"></a>**

**cms resgrp -del**命令用于删除集群中的资源组。

**命令格式<a name="zh-cn_topic_0000001788466568_section1583311215331"></a>**

-   删除资源组名称

    **cms resgrp -del** _RESOURCE GROUP NAME_

-   删除资源组名称及对应的资源。

    **cms resgrp -del** **-r**_ RESOURCE GROUP NAME_

**参数说明<a name="zh-cn_topic_0000001788466568_section13833622336"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|RESOURCE GROUP NAME|资源组名称。|-|


**使用说明<a name="zh-cn_topic_0000001788466568_section78336283319"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466568_section58335210334"></a>**

删除集群中的资源组。

```
[cantian@a12e76db3893 gcc_backup]$ cms resgrp -del GRP_0001
delete resource group succeed.
```

**输出说明<a name="zh-cn_topic_0000001788466568_section7833028335"></a>**

无。

## cms diskiostat<a name="ZH-CN_TOPIC_0000001788477748"></a>

**命令功能<a name="zh-cn_topic_0000001788466532_section206372054567"></a>**

**cms diskiostat**命令用于显示CMS运行日志落盘时间超过5s的条目总数的平均时延。

**命令格式<a name="zh-cn_topic_0000001788466532_section56371454665"></a>**

**cms diskiostat**

**参数说明<a name="zh-cn_topic_0000001788466532_section10227201911717"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788466532_section195381311374"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466532_section56691259101"></a>**

查看CMS运行日志落盘时间超过5s的条目总数的平均时延。

```
[cantian@a12e76db3893 gcc_backup]$ cms diskiostat
0
```

**输出说明<a name="zh-cn_topic_0000001788466532_section186696551011"></a>**

无。

## cms version<a name="ZH-CN_TOPIC_0000001835236985"></a>

**命令功能<a name="zh-cn_topic_0000001788466556_section12299163821117"></a>**

**cms version**命令用于获取当前环境的集群版本信息。

**命令格式<a name="zh-cn_topic_0000001788466556_section1929910380112"></a>**

**cms version**

**参数说明<a name="zh-cn_topic_0000001788466556_section18299153821114"></a>**

无。

**使用说明<a name="zh-cn_topic_0000001788466556_section13299153861115"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788466556_section1429933819112"></a>**

查看集群当前环境的版本信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms version
mem version:3.0.0.
gcc version:3.0.0.
```

**输出说明<a name="zh-cn_topic_0000001788466556_section17299103851116"></a>**

命令回显的部分字段含义如下。

|字符名称|字段含义|
|--|--|
|mem version|内存中的集群版本信息。|
|gcc version|gcc文件中的集群版本信息。|


## cms upgrade<a name="ZH-CN_TOPIC_0000001788637396"></a>

**命令功能<a name="zh-cn_topic_0000001835225809_section1046317182200"></a>**

**cms upgrade**命令用于提升集群的版本信息。

**命令格式<a name="zh-cn_topic_0000001835225809_section446371819207"></a>**

**cms upgrade -version** _MAIN MAJOR REVISION_

**参数说明<a name="zh-cn_topic_0000001835225809_section84631018162013"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|MAIN|升级到的集群目标主版本号。|-|
|MAJOR|升级到的集群目标次版本号。|-|
|REVISION|升级到的集群目标特性版本号。|-|


**使用说明<a name="zh-cn_topic_0000001835225809_section7463131802016"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225809_section114638186209"></a>**

抬升集群的版本信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms upgrade -version 3 3 3
cms upgrade succeed, main_ver=3, major_ver=3, revision=3, inner=2.
[cantian@a12e76db3893 gcc_backup]$ cms version
mem version:3.3.3.
gcc version:3.3.3.
```

**输出说明<a name="zh-cn_topic_0000001835225809_section84631118102020"></a>**

无。

## cms degrade<a name="ZH-CN_TOPIC_0000001835276929"></a>

**命令功能<a name="zh-cn_topic_0000001835225849_section1412710389346"></a>**

**cms degrade**命令用于强制回退集群版本信息。

**命令格式<a name="zh-cn_topic_0000001835225849_section412733817344"></a>**

**cms degrade -version** **-force** _MAIN MAJOR REVISION_

**参数说明<a name="zh-cn_topic_0000001835225849_section9640192117499"></a>**

|**参数**|**说明**|**取值**|
|--|--|--|
|MAIN|集群的主版本号。|-|
|MAJOR|集群的次版本号。|-|
|REVISION|集群的特性版本号。|-|


**使用说明<a name="zh-cn_topic_0000001835225849_section31271238103411"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225849_section181273389347"></a>**

强制回退集群版本信息。

```
[cantian@a12e76db3893 gcc_backup]$ cms degrade -version -force 3 0 0
cms degrade succeed, main_ver=3, major_ver=0, revision=0, inner=2.
```

**输出说明<a name="zh-cn_topic_0000001835225849_section1212783823418"></a>**

无。

# ctbackup<a name="ZH-CN_TOPIC_0000001788477752"></a>











## ctbackup --backup<a name="ZH-CN_TOPIC_0000001835236989"></a>

**命令功能<a name="zh-cn_topic_0000001788626176_section39926938"></a>**

**ctbackup --backup**命令用于对数据库和Cantian引擎相关数据执行全量备份。

**命令格式<a name="zh-cn_topic_0000001788626176_section23798129"></a>**

**ctbackup --backup --target-dir=**_?_ _ _\[**--datadir=**_?_  \] \[**--user=**_?_** **\] \[**--password=**_?_**_ _**\]_ _\[**--host=**_?_** **\] \[**--port=**_?_  \] \[**--defaults-file=**_?_  \] \[**--parallel=**_?_  \] \[**--compress**=_?_\] \[**--skip-badblock**\]

**参数说明<a name="zh-cn_topic_0000001788626176_section12856577"></a>**

|参数|说明|取值|
|--|--|--|
|target-dir|自定义备份数据的存放路径。**cantian**用户需对该路径有读写权限。|-|
|datadir|MySQL元数据路径。|-|
|user|登录MySQL数据库的用户。|-|
|password|登录MySQL数据库用户名的密码。|-|
|host|MySQL监听地址。|默认为XtraBackup中配置的MySQL监听地址。|
|port|MySQL监听端口。|默认为XtraBackup中配置的MySQL监听端口。|
|defaults-file|MySQL配置文件路径。|默认为XtraBackup中配置的MySQL配置文件路径。|
|parallel|备份并发线程数。|默认值：4取值范围1~16。|
|compress|备份数据时使用的压缩算法。|当前仅支持配置为lz4，如果未配置则表示不对备份数据进行压缩。|
|skip-badblock|备份时跳过数据坏块。|未设置时，遇到坏块备份任务将失败。|


**使用说明<a name="zh-cn_topic_0000001788626176_section1393162518177"></a>**

-   需要切换到cantian用户下执行。
-   执行前已正确安装备份恢复工具XtraBackup。
-   Cantian引擎已开启归档。

**使用示例<a name="zh-cn_topic_0000001788626176_section63268730"></a>**

执行全量备份。

```
$ ctbackup --backup --user=myuser --password=mypass --host=192.168.163.101 --port=3306  --target-dir=/home/lyz/backup/base1 --parallel=4
……
[ctbackup]cantian backup execute success and exit with: 0
[ctbackup]cantian data files backup success
[ctbackup]unlock instance success!
```

**输出说明<a name="zh-cn_topic_0000001788626176_section1412117293556"></a>**

无。

## ctbackup --backup --incremental<a name="ZH-CN_TOPIC_0000001788637404"></a>

**命令功能<a name="zh-cn_topic_0000001835265721_section39926938"></a>**

**ctbackup --backup --incremental**命令用于对数据库和Cantian引擎相关数据执行增量备份。

**命令格式<a name="zh-cn_topic_0000001835265721_section23798129"></a>**

**ctbackup --backup --incremental --target-dir=**_?_** **_ _\[**--datadir=**_?_\] \[**--user=**_?_\]** **\[**--password=**_?_\]**_ _**\[**--host=**_?_\]** **\[**--port=**_?_\] \[**--defaults-file=**_?_\] \[**--compress**=_?_\] \[**--skip-badblock**\] \[**--cumulative**\]

**参数说明<a name="zh-cn_topic_0000001835265721_section12856577"></a>**

|参数|说明|取值|
|--|--|--|
|incremental|执行增量备份。|-|
|target-dir|自定义备份数据的存放路径。**cantian**用户需对该路径有读写权限。|-|
|datadir|MySQL元数据路径。|-|
|user|登录MySQL数据库的用户。|-|
|password|登录MySQL数据库用户名的密码。|-|
|host|MySQL监听地址。|默认为XtraBackup中配置的MySQL监听地址。|
|port|MySQL监听端口。|默认为XtraBackup中配置的MySQL监听端口。|
|defaults-file|MySQL配置文件路径。|默认为XtraBackup中配置的MySQL配置文件路径。|
|parallel|备份并发线程数。|默认值：4取值范围1~16。|
|compress|备份数据时使用的压缩算法。|当前仅支持配置为lz4，如果未配置则表示不对备份数据进行压缩。|
|skip-badblock|备份时跳过数据坏块。|未设置时，遇到坏块备份任务将失败。|
|cumulative|执行累积增量备份。|未配置时，默认执行差异增量备份。|


**使用说明<a name="zh-cn_topic_0000001835265721_section1393162518177"></a>**

-   需要切换到cantian用户下执行。
-   增量备份在全量备份的基础上进行，需要创建新的增量备份集路径。
-   累积增量备份和差异增量备份不能混用。

**使用示例<a name="zh-cn_topic_0000001835265721_section63268730"></a>**

执行差异增量备份。

```
$ ctbackup --backup --incremental --user=myuser --password=mypass --host=192.168.163.101 --port=3306 --target-dir=/home/lyz/backup/inc1 --parallel=4
……
[ctbackup]cantian backup execute success and exit with: 0
[ctbackup]cantian data files backup success
[ctbackup]unlock instance success!
```

**输出说明<a name="zh-cn_topic_0000001835265721_section1412117293556"></a>**

无。

## ctbackup --prepare --restore --recover<a name="ZH-CN_TOPIC_0000001835276933"></a>

**命令功能<a name="zh-cn_topic_0000001835225713_section39926938"></a>**

**ctbackup --prepare --restore --recover**命令用于执行普通恢复。

**命令格式<a name="zh-cn_topic_0000001835225713_section23798129"></a>**

**ctbackup --prepare --restore --recover** **--target-dir=**_? _**\[--parallel=**_?_  \] \[**--repair-type=**_?_\] \[**--decompress**\]

**参数说明<a name="zh-cn_topic_0000001835225713_section12856577"></a>**

|参数|说明|取值|
|--|--|--|
|target-dir|备份集路径。|-|
|parallel|恢复并发线程数。|默认值：4取值范围1~16。|
|repair-type|坏块修复类型。|取值范围：return_error：遇到坏块时，恢复任务将失败。replace_checksum：计算并替换坏块的checksum，继续恢复任务。discard_badblock：跳过当前坏块，继续恢复任务。未配置时，默认值为return_error。|
|decompress|恢复时解压备份数据。|当备份命令中指定了compress参数，则需要配置decompress参数。|


**使用说明<a name="zh-cn_topic_0000001835225713_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225713_section63268730"></a>**

执行普通恢复。

```
$ ctbackup --prepare --restore --recover --target-dir=/home/lyz/backup/inc1 --parallel=4
……
[ctbackup]stop cantiand server finished!
```

**输出说明<a name="zh-cn_topic_0000001835225713_section1412117293556"></a>**

无。

## ctbackup --prepare --restore --recover --pitr-time<a name="ZH-CN_TOPIC_0000001788477756"></a>

**命令功能<a name="zh-cn_topic_0000001788626232_section39926938"></a>**

**ctbackup --prepare --restore --recover --pitr-time='**_xxx_**'**命令用于指定时间点恢复。

**命令格式<a name="zh-cn_topic_0000001788626232_section23798129"></a>**

**ctbackup --prepare --restore --recover --target-dir=**_? _\[**--parallel=**_?_  \] \[**--pitr-time='**_?_**' **\] \[**--repair\_type=**_?_\] \[**--decompress**\]

**参数说明<a name="zh-cn_topic_0000001788626232_section12856577"></a>**

|参数|说明|取值|
|--|--|--|
|target-dir|备份集路径。|-|
|parallel|恢复并发线程数。|默认值：4取值范围1~16。|
|pitr-time|指定恢复到的时间点。|参数格式：xxxx-xx-xx xx:xx:xx如：2022-11-07 11:46:00|
|repair-type|坏块修复类型。|取值范围：return_error：遇到坏块时，恢复任务将失败。replace_checksum：计算并替换坏块的checksum，继续恢复任务。discard_badblock：跳过当前坏块，继续恢复任务。未配置时，默认值为return_error。|
|decompress|恢复时解压备份数据。|当备份命令中指定了compress参数，则需要配置decompress参数。|


**使用说明<a name="zh-cn_topic_0000001788626232_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001788626232_section63268730"></a>**

执行PITR指定时间恢复。

```
$ ctbackup --prepare --restore --recover --target-dir=/home/lyz/backup/inc1 --parallel=4 --pitr-time='2023-08-31 20:18:00'
……
[ctbackup]stop cantiand server finished!
```

**输出说明<a name="zh-cn_topic_0000001788626232_section1412117293556"></a>**

无。

## ctbackup --prepare --restore --recover  --pitr-scn<a name="ZH-CN_TOPIC_0000001835236993"></a>

**命令功能<a name="zh-cn_topic_0000001835265681_section39926938"></a>**

**ctbackup --prepare --restore --recover --pitr-scn='**_xxx'_命令用于指定SCN恢复。

**命令格式<a name="zh-cn_topic_0000001835265681_section23798129"></a>**

**ctbackup --prepare --restore --recover --target-dir=**_? _\[**--parallel=**_?_  \] \[**--pitr-scn=**_'?'_** **\] \[**--repair\_type=**_?_\] \[**--decompress**\]

**参数说明<a name="zh-cn_topic_0000001835265681_section12856577"></a>**

|参数|说明|取值|
|--|--|--|
|target-dir|备份集路径。|-|
|parallel|恢复并发线程数。|默认值：4取值范围1~16。|
|pitr-scn|指定恢复到的SCN。|-|
|repair-type|坏块修复类型。|取值范围：return_error：遇到坏块时，恢复任务将失败。replace_checksum：计算并替换坏块的checksum，继续恢复任务。discard_badblock：跳过当前坏块，继续恢复任务。未配置时，默认值为return_error。|
|decompress|恢复时解压备份数据。|当备份命令中指定了compress参数，则需要配置decompress参数。|


**使用说明<a name="zh-cn_topic_0000001835265681_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265681_section63268730"></a>**

执行PITR指定SCN恢复。

```
$ ctbackup --prepare --restore --recover --target-dir=/home/lyz/backup/inc1 --parallel=4 --pitr-scn='75619131392001'
……
[ctbackup]stop cantiand server finished!
```

**输出说明<a name="zh-cn_topic_0000001835265681_section1412117293556"></a>**

无。

## ctbackup --copy-back<a name="ZH-CN_TOPIC_0000001788637408"></a>

**命令功能<a name="zh-cn_topic_0000001835225777_section39926938"></a>**

**ctbackup --copy-back**命令用于执行恢复MySQL元数据。

**命令格式<a name="zh-cn_topic_0000001835225777_section23798129"></a>**

**ctbackup --copy-back --target-dir=**_?_  \[**--datadir=**_?_  \] \[**--parallel=**_?_  \]

**参数说明<a name="zh-cn_topic_0000001835225777_section12856577"></a>**

|参数|参数说明|取值|
|--|--|--|
|target-dir|备份集路径。|-|
|datadir|MySQL元数据路径|-|
|parallel|恢复并发线程数。|默认值：4取值范围1~16。|


**使用说明<a name="zh-cn_topic_0000001835225777_section1393162518177"></a>**

-   需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225777_section63268730"></a>**

恢复MySQL元数据。

```
$ ctbackup --copy-back --target-dir=/home/lyz/backup/inc1 --parallel=4
……
[ctbackup]mysql copyback execute success and exit with: 0
[ctbackup]xtrabackup execute copyback for mysql success!
```

恢复完成后需要修改Mysql元数据属组为deploy\_user，以ctdba为例：

```
chown ctdba:ctdba -hR /mnt/dbdata/remote/metadata_metadata_fs_101_103/node0
```

**输出说明<a name="zh-cn_topic_0000001835225777_section1412117293556"></a>**

无。

## ctbackup --reconciel-mysql<a name="ZH-CN_TOPIC_0000001835276937"></a>

**命令功能<a name="zh-cn_topic_0000001835265625_section39926938"></a>**

**ctbackup --reconciel-mysql**命令用于回放DDL**。**

**命令格式<a name="zh-cn_topic_0000001835265625_section23798129"></a>**

**ctbackup --reconciel-mysql **\[**--user=**_?_  \] \[_ _**--password=**_'?' _\] \[**--host=**_?_  \] \[**--port=**_?_  \]

**参数说明<a name="zh-cn_topic_0000001835265625_section12856577"></a>**

|参数|说明|取值|
|--|--|--|
|user|登录MySQL数据库的用户。|-|
|password|登录MySQL数据库用户名的密码。|-|
|host|MySQL监听地址。|默认为XtraBackup中配置的MySQL监听地址。|
|port|MySQL监听端口。|默认为XtraBackup中配置的MySQL监听端口。|


**使用说明<a name="zh-cn_topic_0000001835265625_section1393162518177"></a>**

-   需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835265625_section63268730"></a>**

回放DDL。

```
$ ctbackup --reconciel-mysql --user=myuser --password=mypass --host=8.40.163.101 --port=3306
[ctbackup]ready to execute reconciel_mysql for mysql!
[ctbackup]get path for mysql succeed!
mysql: [Warning] Using a password on the command line interface can be insecure.
[ctbackup]ctbackup execute reconciel_mysql for mysql success!
```

**输出说明<a name="zh-cn_topic_0000001835265625_section1412117293556"></a>**

无。

## ctbackup --query-incremental-mode<a name="ZH-CN_TOPIC_0000001788477760"></a>

**命令功能<a name="zh-cn_topic_0000001835225729_section39926938"></a>**

**ctbackup --query-incremental-mode**命令用于查询备份集的备份模式。

**命令格式<a name="zh-cn_topic_0000001835225729_section23798129"></a>**

**ctbackup --query-incremental-mode --target-dir=**_?_

**参数说明<a name="zh-cn_topic_0000001835225729_section12856577"></a>**

|字符名称|字段含义|
|--|--|
|**target-dir**|备份集路径。|


**使用说明<a name="zh-cn_topic_0000001835225729_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225729_section63268730"></a>**

查询备份集备份模式

```
$ ctbackup --query-incremental-mode --target-dir=/home/lyz/backup/inc1
[ctbackup]Incrementalmode：[difference].
[ctbackup]cantian query_incremental_mode success.
```

**输出说明<a name="zh-cn_topic_0000001835225729_section1412117293556"></a>**

-   Incrementalmode：difference，差异增量备份
-   Incrementalmode：cumulative，累积增量备份
-   full backup，全量备份

## ctbackup --purge-logs<a name="ZH-CN_TOPIC_0000001835236997"></a>

**命令功能<a name="zh-cn_topic_0000001788466508_section39926938"></a>**

**ctbackup --purge-logs**命令用于清理残留归档日志。

**命令格式<a name="zh-cn_topic_0000001788466508_section23798129"></a>**

**ctbackup --purge-logs**

**参数说明<a name="zh-cn_topic_0000001788466508_section12856577"></a>**

无

**使用说明<a name="zh-cn_topic_0000001788466508_section1393162518177"></a>**

-   需要切换到cantian用户下执行。
-   执行该命令后，使用历史备份集执行PITR恢复命令会导致恢复后的数据不完整。

**使用示例<a name="zh-cn_topic_0000001788466508_section63268730"></a>**

清理残留归档日志。

```
$ ctbackup --purge-logs
[ctbackup]ready to purge logs for cantian!
KmcCheckKmcCtx WSEC_SUCCESS
KmcCheckKmcCtx WSEC_SUCCESS
KmcCheckKmcCtx WSEC_SUCCESS

connected.


SQL> 
Succeed.
Warning:
[ARCH_REMOVE] there exists arch_log with dbid = 0.
remove 3 arch_log in /mnt/dbdata/remote/archive_archive_fs_101_103, lists:
arch_0_0_1_0_1fa0a9c.arc
arch_1_0_1_0_1fa0a9d.arc
arch_0_0_2_1fa0a9c_1fa0aa8.arc


[ctbackup]cantian purge logs execute success and exit with: 0
[ctbackup]cantian purge logs success
```

**输出说明<a name="zh-cn_topic_0000001788466508_section1412117293556"></a>**

执行该命令后将显示被清理的归档日志文件。

若回显中存在“there exists arch\_log with dbid = 0.”，说明存在dbid=0的归档日志，该归档日志需用户自行判断并手动清理。

## ctbackup --archivelog<a name="ZH-CN_TOPIC_0000001788637412"></a>

**命令功能<a name="zh-cn_topic_0000001835225733_section39926938"></a>**

**ctbackup --archivelog**命令用于强制归档。

**命令格式<a name="zh-cn_topic_0000001835225733_section23798129"></a>**

**ctbackup --archivelog**

**参数说明<a name="zh-cn_topic_0000001835225733_section12856577"></a>**

无

**使用说明<a name="zh-cn_topic_0000001835225733_section1393162518177"></a>**

需要切换到cantian用户下执行。

**使用示例<a name="zh-cn_topic_0000001835225733_section63268730"></a>**

强制归档。

```
$ ctbackup --archivelog
[ctbackup]ready to archive log for cantian!
KmcCheckKmcCtx WSEC_SUCCESS
KmcCheckKmcCtx WSEC_SUCCESS
KmcCheckKmcCtx WSEC_SUCCESS

connected.


SQL> 
Succeed.

[ctbackup]cantian archive log execute success and exit with: 0
[ctbackup]cantian archive log success
```

**输出说明<a name="zh-cn_topic_0000001835225733_section1412117293556"></a>**

无。

# ctsql<a name="ZH-CN_TOPIC_0000001835276941"></a>



























## DCL 语法一览表<a name="ZH-CN_TOPIC_0000001835225709"></a>

数据库控制语言DCL\(Data Control Language\)，用来设置或更改数据库事务。

**事务管理<a name="section2067117519166"></a>**

**表 1**  事务管理

|**功能**|**相关SQL**|
|--|--|
|提交事务|COMMIT|
|回滚事务|ROLLBACK|


## DDL 语法一览表<a name="ZH-CN_TOPIC_0000001788626100"></a>

DDL（Data Definition Language数据定义语言），用于定义或修改数据库中的对象，如：表、目录、索引、视图、同名词、数据库、序列、用户、角色、表空间、profile、会话等。

**定义数据库<a name="section13114161962816"></a>**

数据库是组织、存储和管理数据的仓库，而数据库定义主要包括：创建数据库、修改数据库属性。所涉及的SQL语句，请参考下表。

**定义表空间<a name="section719510473289"></a>**

表空间用于管理数据对象，与磁盘上的一个目录对应。所涉及的SQL语句，请参考下表。

**表 1**  表空间定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|创建表空间|CREATE TABLESPACE|
|修改表空间属性|ALTER TABLESPACE|
|删除表空间|DROP TABLESPACE|


**定义表<a name="section1987610270297"></a>**

表是数据库中的一种特殊数据结构，用于存储数据对象以及对象之间的关系。所涉及的SQL语句，请参考下表。

**表 2**  表定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|创建表|CREATE TABLE|
|修改表属性|ALTER TABLE|
|删除表|DROP TABLE|
|删除表中所有数据|TRUNCATE TABLE|


**定义分区表<a name="section1878101510303"></a>**

分区表是一种逻辑表，数据是由普通表存储的，主要用于提升查询性能。所涉及的

SQL语句，请参考下表。

**表 3**  分区表定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|创建分区表|CREATE TABLE PARTITION|
|创建分区|ALTER TABLE|
|修改分区表属性|ALTER TABLE|
|删除分区|ALTER TABLE|
|删除分区表|DROP TABLE|
|分裂分区|ALTER TABLE|


**定义索引<a name="section17581753163019"></a>**

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。所涉及的SQL语句，请参考下表。

**表 4**  索引定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|创建索引|CREATE INDEX|
|修改索引属性|ALTER INDEX|
|删除索引|DROP INDEX|


**定义用户<a name="section117101948319"></a>**

用户是用来登录数据库的，通过对用户赋予不同的权限，可以方便地管理用户对数据库的访问及操作。所涉及的SQL语句，请参考下表。

**表 5**  用户定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|创建用户|CREATE USER|
|修改用户属性|ALTER USER|
|删除用户|DROP USER|


**定义视图<a name="section158538404310"></a>**

视图是从一个或几个基本表中导出的虚表，可用于控制用户对数据访问，请参考下表。

**表 6**  视图定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|创建视图|CREATE VIEW|
|删除视图|DROP VIEW|


**定义注释<a name="section52596501315"></a>**

使用comment语句增加一个关于表、视图注释；支持创建表时，指定列的comment信息。所涉及的SQL语句，请参考下表。

**表 7**  注释定义相关SQL

|**功能**|**相关SQL**|
|--|--|
|增加表和列的注释|COMMENT ON|


## DML 语法一览表<a name="ZH-CN_TOPIC_0000001835265597"></a>

DML（Data Manipulation Language数据操作语言），用于对数据库表中的数据进行操作。如：插入、修改。

**数据操作<a name="section88691443024"></a>**

**表 1**  数据操作

|**功能**|**相关SQL**|
|--|--|
|插入数据|INSERT|
|修改数据|UPDATE|


## DQL 语法一览表<a name="ZH-CN_TOPIC_0000001788626108"></a>

数据库查询语言DQL\(Data Query Language\)，用来查询数据库内的数据。

**表 1**  DQL 语法一览表

|**功能**|**相关SQL**|
|--|--|
|查询数据|SELECT|


## ALTER INDEX<a name="ZH-CN_TOPIC_0000001835225701"></a>

**功能描述<a name="section14715115018115"></a>**

改变一个现有索引的定义。

**注意事项<a name="section1561165831112"></a>**

-   用户更改当前用户的索引，不需要额外授予权限。如果更改其他用户的索引，用户需要被授予ALTER ANY INDEX系统权限，普通用户不可以修改系统用户对象。
-   索引名必须存在，否则报错。
-   数据库重启回滚期间不支持该操作。
-   本地临时表上不支持该操作。

**语法格式<a name="section18181831121"></a>**

```
ALTER INDEX [ schema_name. ]index_name
{    rebuild_clauses
   | rename_clauses
   | physical_attributes_clauses
   | modify_partition_clauses
   | COALESCE
   | UNUSABLE
}
```

-   rebuild\_clauses 子句：

    ```
    { REBUILD [ SUBPARTITION subpart_name | PARTITION part_name] [ONLINE | KEEP STORAGE ONLINE | ONLINE KEEP STORAGE] [TABLESPACE tablespace_name] }
    ```

-   rename\_clauses 子句：

    ```
    { RENAME TO [schema_name.] index_name_new }
    ```

-   physical\_attributes\_clauses 子句：

    ```
    INITRANS integer
    ```

-   modify\_partition\_clauses 子句：

    ```
    MODIFY PARTITION part_name { INITRANS integer | COALESCE | UNUSABLE }
    ```

    或

    ```
    MODIFY SUBPARTITION subpart_name { COALESCE | UNUSABLE }
    ```

**参数说明<a name="section181217920128"></a>**

-   **\[_schema\_name_.\]_index\_name_**

    待重建的索引名。

-   _**rebuild\_clauses**_
    -   **REBUILD \[ SUBPARTITION  _subpart\_name_\[,_subpart\_name_…\] | PARTITION  _part\_name_\[,_part\_name_…\] \] \[ PARALLEL  _n_  \] \[ONLINE | KEEP STORAGE ONLINE | ONLINE KEEP STORAGE\]**

        在线创建或重建索引。这个功能的主要作用是在创建和重建索引过程中，大幅度减少对表加排他锁的时间，从而不阻塞在线业务的运行。

        -   _**subpart\_name**_
            -   二级分区的子分区名。
            -   最多支持指定32个。

        -   _**part\_name**_
            -   分区名 。
            -   最多支持指定32个。
            -   当分区数大于1个时，只支持指定一级分区表的一级分区。

    -   **REBUILD TABLESPACE  _tablespace\_name_**

        复制索引数据到其他表空间。

        -   **_tablespace\_name_**

            其他已存在的表空间名。

-   _**rename\_clauses**_
    -   **RENAME TO \[_schema\_name_.\]  _index\_name_**_**\_new**_

        待重命名的索引名。

-   _**physical\_attributes\_clauses**_
    -   **INITRANS  _integer_**

        修改索引的初始数据页面上事务槽的个数，取值范围是\[1, 255\]。

        -   修改后的新值只对新分配的页面有效，对已经分配的老页面无效。
        -   对于分区索引，会同步修改索引分区及索引二级分区的INITRANS属性。

-   _**modify\_partition\_clauses**_
    -   _**part\_name**_

        需要修改的分区名称。

    -   _**subpart\_name**_

        二级分区的子分区名。

    -   **COALESCE**

        索引某一个分区的空页回收操作。

        -   索引分区收缩不会阻塞整个分区表的业务。
        -   索引分区收缩后，索引分区的大小不会变，只是把空页放在分区的空闲列表上，以供下次申请页面时优先分配。

    -   **INITRANS  _integer_**

        修改分区的初始数据页面上事务槽的个数，取值范围是\[1, 255\]。

        -   修改后的新值只对新分配的页面有效，对已经分配的老页面无效。
        -   修改分区的INITRANS属性，会同步修改该分区的所有子分区的INITRANS。

    -   **UNUSABLE**

        设置失效某个分区的索引。

        -   某个分区的索引失效后，对表进行增删改操作时不会同步维护该索引信息。
        -   如果后续需要再用到该失效分区的索引时必须执行下列操作的任意一种，失效索引才可以正常使用。
            -   重建该分区索引，重建后会自动变成可用状态。
            -   删除该索引新建同名索引。

-   **COALESCE**

    索引空页回收操作。

    -   索引收缩不会阻塞该表的业务。
    -   索引收缩后，索引的大小不会变，只是把空页放在空闲列表上，以供下次申请页面时优先分配。

-   **UNUSABLE**

    设置失效索引。

    -   索引失效后，对表进行增删改操作时不会同步维护该索引信息。
    -   如果后续需要再用到该失效索引时必须执行下列操作的任意一种，失效索引才可以正常使用。
        -   重建该索引，重建后会自动变成可用状态。
        -   删除该索引新建同名索引。

**示例<a name="section192601214141218"></a>**

-   在普通表posts上在线重建及重命名索引。

    ```
    --删除表posts。
    DROP TABLE IF EXISTS posts;
    --创建表posts。
    CREATE TABLE posts(post_id CHAR(2) NOT NULL, post_name CHAR(6) PRIMARY KEY, basic_wage INT,basic_bonus INT);
    --删除索引idx_posts和idx_baisc。
    DROP INDEX IF EXISTS idx_posts ON posts;
    DROP INDEX IF EXISTS idx_baisc ON posts;
    --创建索引idx_posts和idx_baisc。
    CREATE INDEX idx_posts ON posts(post_id ASC, post_name) ;
    CREATE INDEX idx_baisc ON posts(basic_wage );
    --在线重建索引。
    ALTER INDEX idx_posts ON posts REBUILD;
    --重命名索引。 
    ALTER INDEX idx_posts ON posts RENAME TO idx_posts_temp;
    --设置失效索引。
    ALTER INDEX idx_baisc ON posts UNUSABLE;
    ```

-   在分区表education上在线重建及重命名分区索引。

    ```
    --删除表education。
    DROP TABLE IF EXISTS education;
    --创建分区表education。
    CREATE TABLE education(staff_id INT NOT NULL, highest_degree CHAR(8), graduate_school VARCHAR(64), graduate_date DATETIME, education_note VARCHAR(70))
    PARTITION BY LIST(highest_degree)
    (
    PARTITION doctor VALUES ('DOCTOR'),
    PARTITION master VALUES ('MASTER'),
    PARTITION undergraduate VALUES ('SCHOLAR')
    );
    --向分区表education中插入记录1。
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(10,'DOCTOR','Xidian University','2017-07-06 12:00:00','211');
    --向分区表education中插入记录2。
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(11,'DOCTOR','Northwest A&F University','2017-07-06 12:00:00','211&985');
    --向分区表education中插入记录3。
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(12,'MASTER','Northwestern Polytechnical University','2017-07-06 12:00:00','211&985');
    --向分区表education中插入记录4。
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(15,'SCHOLAR','Xi’an University of Architecture and Technology','2017-07-06 12:00:00','NOT 211 OR 985');
    --向分区表education中插入记录5。
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(18,'MASTER','Xi’an University of Technology','2017-07-06 12:00:00','not 211 or 985');
    --向分区表education中插入记录6。
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(20,'SCHOLAR','Capital Normal University','2017-07-06 12:00:00','211和985');
    COMMIT;
    --删除索引idx_training。
    DROP INDEX IF EXISTS idx_training ON education;
    --创建分区索引。
    CREATE INDEX idx_training ON education(staff_id ASC, highest_degree) LOCAL (PARTITION doctor,PARTITION master, PARTITION undergraduate);
    --重建索引。
    ALTER INDEX idx_training ON education REBUILD;
    --重命名分区索引。
    ALTER INDEX idx_training ON education RENAME TO idx_training_temp;
    --修改索引的INITRANS。
    ALTER INDEX idx_training_temp ON education INITRANS 10;
    --修改索引分区的INITRANS。
    ALTER INDEX idx_training_temp ON education MODIFY PARTITION doctor INITRANS 20;
    --设置失效某个分区的索引。
    ALTER INDEX idx_training_temp ON education MODIFY PARTITION doctor UNUSABLE;
    ```

## ALTER TABLESPACE<a name="ZH-CN_TOPIC_0000001788626076"></a>

**功能描述<a name="section15482165152815"></a>**

修改表空间。

**注意事项<a name="section12761515162810"></a>**

-   执行该语句的用户需要有ALTER TABLESPACE系统权限。
-   增加数据文件，修改AUTOEXTEND属性及重命名表空间，需在数据库open状态下执行。
-   只能对用户表空间设置AUTOOFFLINE。
-   带SHARD关键字仅支持分布式场景，单机不生效。
-   临时表空间的temp文件的首页在物理上可能存在数据不一致情况，属正常现象。

**语法格式<a name="section156461206287"></a>**

```
ALTER TABLESPACE tablespace_name
    {   datafile_tempfile_clauses
      | RENAME TO new_tablespace_name
      | SHRINK SPACE KEEP integer [ K | M | G | T ]
      | AUTOOFFLINE { ON | OFF }
      | PUNCH {integer [K | M | G ] }
    }
```

-   _datafile\_tempfile\_clauses_  子句：

    ```
    {   ADD DATAFILE {datafile_tempfile_spec [ , ... ]}
        | autoextend_clause  [SHARD]
    }
    ```

    -   _datafile\_tempfile\_spec_  子句：

        ```
        file_name SIZE integer [ K | M | G ] [COMPRESS] [ autoextend_clause ][ segments integer ]
        ```

        -   autoextend\_clause 子句：

            ```
            AUTOEXTEND {   OFF
                            | ON [ NEXT integer [ K | M | G] ] 
                                 [ MAXSIZE { integer [ K | M | G] | UNLIMITED } ]
                        } 
            ```

**参数说明<a name="section92703258283"></a>**

-   **_tablespace\_name_**

    待修改表空间的名称，当表空间不存在时报错。

-   **ADD DATAFILE**

    向表空间添加数据文件。

-   **_autoextend\_clause_**

    修改表空间AUTOEXTEND属性。

-   **AUTOOFFLINE**

    设置表空间是否开启自动离线。

    -   AUTOOFFLINE为ON时，开启自动离线的用户表空间，在数据库启动过程中存在文件打开失败的问题时，会自动离线该用户表空间；若用户表空间在数据库启动成功后出现问题，则不会自动离线。
    -   开启自动离线功能时，如果用户表空间发生损坏或其他故障时，在启动数据库时可以将数据库加载到Mount状态；如果没有开启自动离线功能，表空间发生故障或损坏时，数据库将无法正常启动。

-   **_datafile\_tempfile\_spec_**

    表空间数据文件，可以用逗号分隔多个数据文件，数据文件中暂时不支持中文。

    **_file\_name_**

    新生成的数据文件在操作系统下的路径＋新数据文件名。指定文件名为相对路径时，默认保存在数据目录的data目录下。

    **SIZE_ integer_\[ K | M | G \]**

    数据文件大小。

    **K：**单位KB

    **M：**单位MB

    **G：**单位GB

    undo表空间的取值范围：\[128M,32G\]，system表空间和sysaux表空间的取值范围：\[128M,8TB\]，其它表空间的取值范围：\[1M,8TB\]。

    **COMPRESS**

    指定新增的数据文件为压缩属性。压缩文件用来存储压缩属性的表，当使用表压缩特性时，需要同步在对应表空间下创建压缩文件。

    **_autoextend\_clause_**

    表空间的AUTOEXTEND为on时，可以手动指定每次扩展的大小。

    -   不指定AUTOEXTEND字句，默认不自动扩展。
    -   指定AUTOEXTEND OFF，默认不自动扩展。
    -   指定AUTOEXTEND ON时，可设置的属性如下：
        -   “NEXT”指定自动扩展的大小。若用户未指定时，默认值为16MB。
        -   “MAXSIZE”指定数据文件自动扩展的上限。
            -   若用户未指定或指定为 "UNLIMITED" 时，undo表空间的上限大小为32GB，其它表空间的上限大小为 8TB。
            -   若用户指定了上限值，则undo表空间指定的上限值不可大于32GB，其它表空间指定的上限值不可大于 8TB。
            -   若用户既指定了上限值也通过“NEXT”指定了自动扩展大小，则指定的上限值不得小于用户指定的自动扩展值。

    _**segments integer**_

    扩展的SEGMENT数量。

    -   SEGMENTS子句仅在RESTRICT模式下可用。
    -   SEGMENTS子句仅支持UNDO表空间设置。
    -   使用SEGMENTS子句时，仅支持单次添加单个数据文件。
    -   SEGMENTS子句的取值下限为1，在\_UNDO\_SEGMENTS尚未达到1024上限时，子句的上限取值为1024 减去 \_UNDO\_SEGMENTS的大小。例如当前已有的\_UNDO\_SEGMENTS数量为32，则使用SEGMENTS子句可设置的上限为1024-32=992，但若\_UNDO\_SEGMENTS已经为1024了，那么此时无法继续扩展。
    -   由于SEGMENTS子句是一种在受限模式下使用的补救措施，其过程包含创建文件、SEGMENTS扩展、控制文件及配置文件的持久化多个过程，故而整个过程无法保证操作的原子性。如果在使用SEGMENTS子句的过程中出现异常，需要用户根据情况自行处理，异常情况通常包括以下几种：
        -   主备机添加UNDO文件成功，但是扩展未完成，此时可看做用户添加了一个UNDO文件，但是未进行SEGMENT的扩展。
        -   备机的控制文件及配置文件中的\_UNDO\_SEGMENTS是SEGMENTS扩展后的值，但是主机的控制文件及配置文件仍是SEGMENTS扩展前的值，此时出现主备机\_UNDO\_SEGMENTS不一致的情况， 这种情况只能用户介入通过重建备机的方式解决。
        -   主机的控制文件及配置文件中的\_UNDO\_SEGMENTS值不匹配，重新启动时报错，此时需要用户介入将配置文件中的\_UNDO\_SEGMENTS中的值改为控制文件中的值。
        -   主机的控制文件及配置文件中的\_UNDO\_SEGMENTS是SEGMENTS扩展后的值，但是备机的控制文件及配置文件仍是SEGMENTS扩展前的值，此时出现主备机\_UNDO\_SEGMENTS不一致的情况， 这种情况只能用户介入通过重建备机的方式解决。
        -   主备机由于环境硬件资源的不一致导致备机在扩展SEGMENT的过程中出现malloc内存失败，表现为备机CRASH且日志中打印“\[SPACE\] ABORT INFO: failed to allocate memory for extend %u undo segments"的报错信息，此时可先尝试启动备机，如果无法正常启动，则只能通过重建备机的方式解决。

            注意，每扩展一个SEGMENT需要额外malloc约600字节内存，用户需根据自己的实际情况酌情扩展。

    -   UNDO SEGMENTS扩展和UNDO SPACE切换在机制上不相容，故当数据库执行过UNDO SEGMENTS扩展后，再去执行UNDO SPACE切换时会报错。

-   **RENAME TO  _new\_tablespace\_name_**

    修改表空间名字。

-   **SHRINK SPACE KEEP **_**integer**_** \[ K | M | G | T \]**

    -   收缩表空间，在RESTRICTED模式下，保证事务无残留的前提下可以重建UNDO表空间。

    -   在OPEN模式下可以对除TEMP表空间之外的其他表空间进行收缩，TEMP表空间需要在OPEN RESTRICT模式下进行收缩。

    -   表空间实际可收缩的空间大小取决于表空间各个数据文件从HWM开始的连续空闲空间大小。

    -   用户指定的KEEP size为一个建议值，其与实际可保留空间\(REAL KEEP size\)的关系如下：
        -   KEEP size \>  REAL KEEP size，则以用户指定的KEEP size为准；
        -   KEEP size <= REAL KEEP size，则以实际可保留空间为准；

    **K：**单位KB

    **M：**单位MB

    **G：**单位GB

    **T：**单位TB

    表空间的取值范围：\[1M, 8000T\]。

-   **SHARD**

    命令支持下发至所有CN和DN 节点，仅支持AUTOEXTEND ，AUTOPUEGE在所有分片生效。该关键字仅支持分布式场景，单机不生效。

-   **PUNCH**

    压缩表空间，对bitmap表空间中的空闲页面进行压缩，当前只对bitmap表空间有效，加密，普通，默认表空间均不可进行压缩。

    用户可以指定需要压缩空闲页面的大小。

    **K：**单位KB

    **M：**单位MB

    **G：**单位GB

    设置压缩空间的取值范围：\[1M, 500G\]。

**示例<a name="section1079432672812"></a>**

-   向表空间tbs\_human中添加数据文件。

    ```
    --创建表空间tbs_human。
     CREATE TABLESPACE tbs_human DATAFILE '-dfile_tbs_01' SIZE 32M AUTOEXTEND ON NEXT 10M;
    ```

    ```
    --向表空间tbs_human中添加数据文件privilege_dfile（大小是32M），manager_dfile（大小是32M）和section_dfile（大小是32M）。
     ALTER TABLESPACE tbs_human ADD DATAFILE '-privilege_dfile' SIZE 32M, 'manager_dfile' SIZE 32M, 'section_dfile' SIZE 32M;
    ```

-   删除表空间tbs\_human中的数据文件manager\_dfile。

    ```
    ALTER TABLESPACE tbs_human DROP DATAFILE 'manager_dfile';
    ```

-   修改表空间tbs\_human为自动扩展，数据插满时，表空间自动扩展，可手动指定每次扩展大小。

    ```
    ALTER TABLESPACE tbs_human AUTOEXTEND ON NEXT 5M;
    ```

-   将表空间名称tbs\_human修改为data\_tbs\_human：

    ```
    ALTER TABLESPACE tbs_human RENAME TO data_tbs_human;
    ```

## ALTER TABLE<a name="ZH-CN_TOPIC_0000001835265585"></a>

**功能描述<a name="section15482165152815"></a>**

ALTER TABLE功能指通过更改、添加、删除列和约束来更改表的定义，功能包括：

-   列的添加、删除、修改、重命名。
-   约束的添加、删除。
-   约束的启动和禁用。
-   修改表的名称。
-   分裂分区。

**注意事项<a name="section12761515162810"></a>**

-   执行该语句的用户需要有ALTER TABLE/ALTER ANY TABLE系统权限，普通用户不可以修改系统用户对象。
-   当指定表名、列名、约束名冲突、无效，数据和启用非验证状态冲突时，返回包含有效信息的错误提示。
-   修改表中列属性时，保证表中所有记录该列为NULL。如果该列不为NULL，NUMBER/VARBINARY/DECIMAL\(p,s\)/CHAR/VARCHAR的大小允许改大，其中DECIMAL中s的大小不允许修改，其他类型和操作均不支持。
-   增加和修改列属性时，不能指定列唯一索引、主键索引、外键inline约束。
-   _shrink\_clause_、_row\_movement\_clause_和字符集目前只支持SQL解析。
-   ALTER TABLE不支持外部表。
-   _enable\_disable\_clause_只支持外键和check约束。
-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section156461206287"></a>**

```
ALTER TABLE [ schema_name. ]table_name
    {   alter_table_properties
      | column_clauses
      | constraint_clauses
      | partition_clauses
      | enable_disable_clause
      | set_interval_clause
      | logic_replication_clauses
    }
```

-   _alter\_table\_properties_  子句：

    ```
    {   physical_attributes_clause
        | RENAME TO new_table_name
        | shrink_clause
        | row_movement_clause
        | AUTO_INCREMENT [ = ] value
        | {ENABLE | DISABLE} ALL TRIGGERS
     }
    ```

    -   _physical\_attributes\_clause_  子句：

        ```
        {   PCTFREE integer 
            | INITRANS integer
            | APPENDONLY { ON | OFF }
            | storage_alter_clause
         }
        ```

        -   _storage\_alter\_clause_子句：

            ```
            STORAGE ( MAXSIZE { UNLIMITED | integer [K | M | G | T] } )
            ```

    -   _shrink\_clause_  子句：

        ```
        SHRINK SPACE [ COMPACT ] [ PERCENT NUM | TIMEOUT NUM ]
        ```

-   _column\_clauses_  子句：

    ```
    {   add_column_clause
        | modify_column_clause
        | drop_column_clause 
        | rename_column_clause
     }
    ```

    -   _add\_column\_clause_  子句：

        ```
        --新增单列。 ADD [ COLUMN ] column_name datatype_name [ DEFAULT expr [ON UPDATE expr ] ] [ COMMENT 'string' ] [ COLLATE collation_name ] [AUTO_INCREMENT] [ inline_constraint ] 
        ```

        ```
        --新增多列。 ADD ( [ COLUMN ] { column_name datatype_name [ DEFAULT expr [ON UPDATE expr ] ] [ COMMENT 'string' ] [ COLLATE collation_name ] [AUTO_INCREMENT] [ inline_constraint ]  } [ , ... ] )
        ```

        -   _inline\_constraint_  子句：

            ```
            [ CONSTRAINT constraint_name ]{   [ NOT ] NULL
                                               | CHECK( expr )
                                               | PRIMARY KEY
                                               | UNIQU
                                            }[ ... ]
            ```

    -   _modify\_column\_clause_  子句：

        ```
        --变更列。 
        MODIFY ( { column_name [ new_datatype_name ] [ DEFAULT expr [ ON UPDATE expr ] ] 
                                                    [ COMMENT string ]
                                                    [ COLLATE collation_name ]
                                                    [ inline_constraint ]  } [ , ... ]
                )
         --收缩LOB字段占用的空间。
         MODIFY LOB(column_name) (SHRINK SPACE)
        ```

    -   _drop\_column\_clause_  子句：

        ```
        DROP [ COLUMN ] column_name
        ```

    -   _rename\_column\_clause_  子句：

        ```
        RENAME COLUMN old_name TO new_name
        ```

-   _constraint\_clauses_  子句：

    ```
    {   ADD out_of_line_constraint
        | DROP CONSTRAINT [ IF EXISTS ] constraint_name
        | RENAME CONSTRAINT old_constraint_name  TO new_constraint_name
     }
    ```

    -   _out\_of\_line\_constraint_  子句：

        ```
        [ CONSTRAINT [ IF NOT EXISTS ] constraint_name ]
         {   UNIQUE( column_name [ , ... ] ) [ constraint_state_clause ] [ PARALLEL n ]
           | PRIMARY KEY( column_name [ , ... ] ) [ constraint_state_clause ] [ PARALLEL n ]
           | CHECK( expr )
           | FOREIGN KEY( column_name [ , ... ] ) references_clause_ex
          }
        ```

        -   _constraint\_state\_clause_  子句：

            _constraint_\__state\_clause_  子句中除了using\_index\_clause以外都只是实现语法兼容，这些选项在当前版本中暂不生效。另外，这些选项可以连续指定，并无先后顺序区别。同一组选项也可多次指定，但解析结果中保存的是该组选项最后一次指定的值。

            ```
            [ NOT DEFERRABLE | DEFERRABLE ]
            [ INITIALLY { IMMEDIATE | DEFERRED } ]
            [ RELY | NORELY ]
            [ VALIDATE | NOVALIDATE ]
            [ ENABLE | DISABLE ]
            [ using_index_clause ]
            ```

            -   _using\_index\_clause_  子句：

                ```
                USING INDEX
                     [   INITRANS integer
                       | TABLESPACE tablespace_name
                      | LOCAL [ ( { PARTITION partition_name [   TABLESPACE tablespace_name
                                                               | INITRANS integer
                                                                | PCTFREE integer
                                                                 | ( { SUBPARTITION subpartition_name [ TABLESPACE tablespace_name ] }[, ... ] )
                                                              ]
                                                            } [ , ... ]
                                  )
                              ]
                         ] [ ... ]
                ```

        -   _references\_clause\_ex_  子句：

            父表不指定列，默认取父表的主键，如果父表的主键不存在，则报错。

            ```
            REFERENCES [ schema_name. ]object_table_name [( column_name [ , ... ] )]
                [ ON DELETE {   CASCADE
                               | SET NULL
                             }
                 ]
            ```

-   _partition\_clauses_  子句：

    ```
    {   add_partition_clause
       | drop_partition_clause
        | truncate_partition_clause
        | coalesce_partition_clause
       | split_partition_clause
       | modify_partition_clause
     }
    ```

    -   _add\_partition\_clause_  子句：

        ```
        ADD PARTITION partition_name
            {   VALUES LESS THAN ( {   partition_value
                                     | MAXVALUE
                                  }[ , ... ]
                                  )      | VALUES (   partition_value [ , ... ]
                        | DEFAULT )
             }
            [ TABLESPACE tablespace_name ]
            [ PCTFREE integer ][ storage_clause ]
            { FORMAT CSF |  [ COMPRESS ]
               [ ( { SUBPARTITION subpartition_name (
                         {   VALUES LESS THAN ( { subpartition_value
                                               | MAXVALUE
                                              }[, ... ]
                                            )
                           | VALUES ( {subpartition_value [, ... ]
                                     | DEFAULT
                                    }[, ... ]
                                  )
                         }
                         [ TABLESPACE tablespace_name ]
                     } [, ... ]
                  )
                ]
             } 
        ```

        ```
        MODIFY PARTITION partititon_name ADD SUBPARTITION
             {   VALUES LESS THAN ( { subpartition_value
                                     | MAXVALUE
                                    }[, ... ]
                                   )
               | VALUES ( subpartition_values [, ... ]
                         | DEFAULT )
            }
             [TABLESPACE tablespace_name ]
        ```

        -   _storage\_clause_  子句：

            ```
            STORAGE ( {  INITIAL integer [K | M | G | T]
                          |MAXSIZE { UNLIMITED | integer [K | M | G | T] }
                       } [ ...] )
            ```

    -   _drop\_partition\_clause_  子句：

        ```
        DROP { PARTITION partition_name \ SUBPARTITION subpartition_name }
        ```

    -   _truncate\_partition\_clause_  子句：

        ```
        TRUNCATE { PARTITION partition_name \ SUBPARTITION subpartition_name } [   DROP STORAGE
                                             | REUSE STORAGE
                                             | PURGE
                                           ]
        ```

    -   _coalesce\_partition\_clause_  子句：

        ```
        COALESCE PARTITION
        MODIFY PARTITION partition_name COALESCE SUBPARTITION
        ```

-   _split\_partition\_clause _子句：

    ```
    SPLIT PARTITION partition_name AT(range_value) INTO (PARTITION part_name1 [ TABLESPACE space_name ], PARTITION part_name2 [ TABLESPACE space_name ]) [UPDATE GLOBAL INDEXES]
    SPLIT SUBPARTITION subpartition_name AT(range_values) INTO (SUBPARTITION subpa_name1 [TABLESPACE space_name], SUBPARTITION subpart_name2 [TABLESPACE space_name]) [UPDATE GLOBAL INDEXES]
    ```

-   _modify\_partition\_clause_子句：

    ```
    MODIFY PARTITION partition_name { INITRANS integer | storage_alter_clause }
    ```

    -   _storage\_alter\_clause_子句：

        ```
        STORAGE (MAXSIZE { UNLIMITED | integer [K | M | G | T] } ) 
        ```

-   _enable\_disable\_clause_子句：

    ```
    { ENABLE | DISABLE } { [ VALIDATE | NOVALIDATE ] CONSTRAINT constraint_name | [ PARTITION | SUBPARTITION ] NOLOGGING }
    ```

-   _set\_interval\_clause_子句：

    ```
    SET INTERVAL([interval_value])
    ```

-   _logic\_replication\_clauses_子句：

    ```
    [([ partition_name \ subpartition_name ][ , ... ])] ADD LOGICAL LOG(UNIQUE index_name)| [([partition_name | subpartition_name ][ , ... ])] ADD LOGICAL LOG(PRIMARY KEY) | DROP LOGICAL LOG
    ```

**参数说明<a name="section92703258283"></a>**

-   **\[_schema\_name_.\]**

    用户名。不指定时默认是当前登录用户。

-   **_table\_name_**

    表名，表必须存在。

-   **_alter\_table\_properties_**

    修改表存储属性。例如LOB\_storage\_clause指定lob字段单独segment储存，可以指定线内存储和线外存储。目前存储层只支持线外存储。

    -   _**physical\_attributes\_clause**_
        -   **INITRANS  _integer_**

            修改表的初始数据页面上事务槽的个数，取值范围是\[1, 255\]。

            -   修改后的新值只对新分配的页面有效，对已经分配的老页面无效。
            -   对于分区表，会同步修改表分区及表二级分区的INITRANS属性。

        -   _**storage\_alter\_clause**_

            表的存储空间的最大值。

            -   **UNLIMITED**

                表示不限制表存储空间的最大值。

            -   **_integer _\[K | M | G | T\]**

                设置表的存储空间最大值，取值范围是\[1M, 1T\]。

    -   **APPENDONLY \{ ON | OFF \}**

        并发插入时，各线程独立扩展空间，提升表插入数据速度。默认为关闭。使用APPENDONLY 时需谨慎操作，使用不当将造成大量空间浪费。

        -   **ON**

            并发插入时，各个线程独立扩展空间。

            -   对于分区表，当把APPENDONLY设置为ON时，并行插入场景会有问题，需要用户提前组织好每个并行线程所插入的数据，确保每个线程内插入的时候不会切换分区，即一个线程对应一个分区。
            -   HASH分区表的不建议设置APPENDONLY为ON。

        -   **OFF**

            并发插入时，各个线程不独立扩展空间。

    -   **_shrink\_clause_**

        收缩子句。

        -   **SPACE**
            -   空间。执行ALTER TABLE SHRINK SPACE语句时，如果并发的执行SELECT语句，可能会读到不一致的结果。因为shrink会截断表，导致row id发生变化，如果按照索引去找，找不到对应的数据。由于shrink表会使得表索引膨胀，建议shrink表的同时，使用ALTER INDEX REBUILD ONLINE对该表的所有索引进行重建。
            -   表模式为RCR模式场景下，shrink行链接和行迁移优化不支持，因此表shrink可能不生效。

        -   **COMPACT**

            压缩选项，带compact选项，表压缩时只做表的段整理，不压缩高水位。

        -   **PERCENT NUM**

            SHRINK比例选项。取值范围为\[1,100\]的整数值，代表着本次欲SHRINK的比例。

            >![](public_sys-resources/icon-note.gif) **说明：** 
            >-   对于存在行链接或者行迁移的表，可能需要增大NUM，才能使空间回收。
            >-   在操作时如果出现表里数据很少，但是shrink之后segment大小没有被压缩的情况，可能是因为之前删除提交时触发了延期清理，导致无法shrink。此时可以通过以下命令对表进行全表扫描查询，来触发一次清理之后再进行shrink操作。
            >    ```
            >    select /*+full(table_name)*/ count(*) from table_name;
            >    ```

        -   **TIMEOUT NUM**

            控制SHRINK的时间，取值范围为\(0,4294967295\)，单位为秒。

            -   此接口采用后台异步SHRINK方式。当接口返回成功后，表的SPACE不会被立即SHRINK，而是将表加入后台，等待后台异步SHRINK。当系统MIN SCN达到表的可回收SCN后，后台才会对此表进行真正的SHRINK SPACE操作。

                注意：当表在后台等待时间超过\_ASHRINK\_WAIT\_TIME限定时间，则会忽略MIN SCN发起强制SHRINK。后台表的状态可以查询DV\_ASYNC\_SHRINK\_TABLES视图。

            -   超时时间不是精确的，会存在误差。
            -   此接口可以保证SHRINK TABLE与DML或者只读操作并发时，DML或者只读操作不会出现不一致读写。但是无法保证CC隔离级别的只读一致性。
            -   此接口的空间回收率，可能没有其他几个接口的空间回收率高。
            -   此接口与PERCENT NUM接口互斥，不可一起使用。
            -   此接口执行完成之后，在后台完成SHRINK之前，若执行对这张表的其他DDL操作，会导致这张表的后台异步SHRINK强制结束，不进行任何空间回收。
            -   无法保证备机上的一致性。
            -   后台同时等待回收的表，最多只能有32768张。
            -   存在行迁移或者行链接的表，可能需要增大NUM，才能使空间回收。

    -   **PCTFREE  _integer_**

        为一个块保留的空间百分比。当数据块的可用空间低于该空间百分比时，只能更新该数据块的数据，不能向该数据块插入新数据。取值范围是\[0,80\]，默认值是8。

    -   **RENAME TO  _new\_table\_name_**

        重命名表名称。

    -   **AUTO\_INCREMENT \[ = \] value**

        修改表自增列的起始值。不指定时，从1开始。

    -   **\{ENABLE | DISABLE\} ALL TRIGGERS**

        启用或禁止触发器。

-   **_column\_clauses_**

    修改表属性，包括增加、删除、修改列。

    -   _**add\_column\_clause**_

        增加列。

    -   **DEFAULT  _expr_  \[ON UPDATE_ expr_\]**

        列默认值支持表达式，在创建DDL时，如果DEFAULT是常量表达式会向列类型做兼容检查。

        -   \[on update expr\] ：兼容语法，UPDATE行数据，不指定该列，取update默认值填充。
        -   insert和update default expr最大长度为1024英文字符长度，default后面的文本超过最大长度将会报错“CT-00611, default value string is too long, exceed 1024.”。

    -   **COMMENT_ 'string'_**

        指定列的注释，通过MY\_COL\_COMMENTS系统视图查看。

    -   **COLLATE** _**collation\_name**_

        定义排序的规则。当比较两个列的数据时，根据所定义的排序规则确定哪个比较大或者是否相等。

        _collation\_name_  表示所定义的排序规则的名称，取值如下：

        -   UTF8\_BIN：适用UTF8字符集。将所有字符看作二进制串，然后从最高位往最低位比对。区分大小写。
        -   UTF8\_GENERAL\_CI：适用UTF8字符集，不区分大小写。
        -   UTF8\_UNICODE\_CI：适用UTF8字符集，不区分大小写。
        -   GBK\_BIN：适用GBK字符集，区分大小写。
        -   GBK\_CHINESE\_CI：适用GBK字符集，不区分大小写。

    -   **_inline\_constraint_**

        列约束，作为列定义的一部分，现支持\[NOT\] NULL、UNIQUE、PRIMARY KEY、唯一索引、外键、check约束。

    -   **_modify\_column\_clause_**

        修改指定的一列或多列的属性，包括修改列的数据类型、在不违反已有约束情况下可为该列添加列约束及收缩LOB字段占用的空间。

        修改列的数据类型，只有在空表或者列数据全部为NULL时，可以做不兼容的数据类型修改。做兼容数据类型修改必须满足表中有数据，且待修改列的值不全是NULL。目前支持的兼容数据类型修改包括：

        -   VARCHAR类型和CHAR类型相互转换（修改后的长度不小于修改前的长度）。
        -   VARCHAR、CHAR、BINARY类型扩大长度。
        -   NUMBER、DECIMAL类型扩大范围（scale和precision - scale都不得小于修改前）。
            -   _**new\_datatype**_**_\_name_**

                修改后的列的数据类型。

    -   _**drop\_column\_clause**_

        删除列。

        -   **DROP \[ COLUMN \] column\_name**

            删除列字段。**column\_name**为列的名称。

    -   _**rename\_column\_clause**_

        重命名列。

        -   **RENAME COLUMN  _old\_name_  TO **_**new\_name**_

            重命名列字段。

            -   **_old\_name_**

                待重命名的列字段名称。

            -   _**new\_name**_

                重命名后的列字段名称。

    **_constraint\_clauses_**

    修改表约束，包括增加、删除行内约束、行外约束。

    -   **_ADD out\_of\_line\_constraint_**

        添加行外约束。

        -   **IF NOT EXISTS**

            创建行外约束的时候，如果约束已经存在，不做改动，直接返回成功。

        -   **_using\_index\_clause_**

            外部索引语句。

            -   **INITRANS  _integer_**

                存储块上的初始化分配空间。integer为空间大小。

            -   **TABLESPACE  _tablespace\_name_**

                指定表空间。tablespace\_name为表空间的名称**。**

            -   **LOCAL**

                创建分区表的本地索引。

        -   **CHECK\( expr \)**

            对列值校验。若列插入数据为NULL，则默认校验为TRUE。

        -   **_references\_clause\_ex_**

            外键约束子句。

            -   **ON DELETE \{ CASCADE | SET NULL \}**

                该属性用于外键，参照外表发生删除时，本表级联变化。

            **CASCADE**

            本表删除。

            **SET NULL**

            本表设置为NULL。

        -   **PARALLEL** **_n_**

            创建主键或者唯一约束时，指定创建对应索引时的并行度。

            _n_是并行度，取值范围是\[1, 64\]。

    -   **DROP CONSTRAINT \[ IF EXISTS \]  _constraint\_name_**

        删除约束，_**constraint\_name**_为约束的名称。

        -   **IF EXISTS**

            如果约束不存在，直接返回成功。

        -   **RENAME CONSTRAINT  _old\_constraint\_name _TO  _new\_constraint\_name_**

            重命名约束名。

            -   **_old\_constraint\_name_**

                待重命名的约束名称。

            -   **_new\_constraint\_name_**

                重命名后的新约束名称。

-   **_partition\_clauses_**

    分区子句。

    -   _**add\_partition\_clause**_

        增加分区子句。

        -   **VALUE LESS THAN**

            值小于。

        -   **_partition\_value_**

            分区值。

        -   **MAXVALUE**

            最大值。

        -   **VALUES**

            值为。

        -   **DEFAULT**

            默认值。

        -   **INITIAL** **_integer _\[K | M | G | T\]**

            表的初始大小，默认一个表的初始都是一个EXTENT，可通过INITIAL来指定表的初始大小。取值范围是\[64K, 1T\]。

        -   **MAXSIZE** **\{ UNLIMITED |  _integer _\[K | M | G | T\] \}**

            表的存储空间的最大值。

            -   **UNLIMITED**

                表示不限制表存储空间的最大值。

            -   **_integer _\[K | M | G | T\]**

                设置表的存储空间最大值，取值范围是\[1M, 1T\]。

        -   **FORMAT CSF**

            注意，对于带CSF属性的HASH分区来说，由于HASH分区添加时会导致数据重分布\(数据重分布时会做CSF属性的约束校验\)，故带CSF属性的HASH分区添加时可能会报错，报错与否取决于是否满足CSF属性约束。

        -   **COMPRESS**

            添加一个压缩分区。需确保此压缩分区所处的表空间内具有压缩属性文件，否则插入数据时会报错。

    -   **_drop\_partition\_clause_**
        -   **DROP PARTITION  _partition\_name_**

            删除分区，_partition\_name_为分区名。

        -   **DROP SUBPARTITION**_**subpartition\_name**_

            删除二级分区的子分区，_subpartition\_name_为子分区的名字。

    -   **_truncate\_partition\_clause_**

        清空分区子句，_partition\_name_  为分区名称，_ subpartition\_name_为子分区名。

        -   **DROP STORAGE**

            清除存储空间。

        -   **REUSE STORAGE**

            重用空间。

        -   **PURGE**

            清空回收站。

    -   **_coalesce\_partition\_clause_**
        -   **COALESCE PARTITION**

            将最后一个分区的数据插入到前边的某个分区里，再把最后一个分区删除。

            -   仅限hash分区才能执行COALESCE PARTITION语句，无需指定分区名。

            -   如果只剩一个分区，执行COALESCE PARTITION语句会报错。
            -   如果被收缩的分区与其将要迁移至的分区的CSF属性不一致时会报错。

        -   **MODIFY PARTITION  _partition\_name_  COALESCE SUBPARTITION**

            将某个父分区下面最后一个子分区的数据插入到前面某个子分区中，再把最后一个子分区删除。

            -   只有当子分区类型为hash分区时才能执行COALESCE SUBPARTITION语句，需要指定需要执行收缩操作的父分区的名字，子分区名字无需指定。
            -   如果父分区下面只剩一个子分区，执行COALESCE SUBPARTITION语句会报错。

    -   **_split\_partition\_clause_**

        分裂分区，将指定的（子）分区分裂为两个（子）分区，原始分区的数据重分布到新的分区中。当前仅RANGE分区支持split操作。对于带CSF的分区来说，分裂后的分区CSF属性与原始分区一致。

        -   _**（sub）partition\_name**_

            需要分裂的（子）分区名称。

        -   **_（sub）part\_name1_** **_（sub） part\_name2_**

            分裂后新的（子）分区名称，两个（子）分区名称不能重复。

        -   **range\_value**

            分裂的边界值。

        -   **UPDATE GLOBAL INDEXES**
            -   若指定update global indexes，则数据重分布完会自动重建全局索引（如果有的话）。

            -   若不指定，则全局索引处于invalid的状态。

    -   _**modify\_partition\_clause**_

        修改分区的属性。

        -   _**partition\_name**_

            需要修改的分区名称。

        -   **INITRANS  _integer_**

            修改分区的初始数据页面上事务槽的个数，取值范围是\[1, 255\]。

            -   修改后的新值只对新分配的页面有效，对已经分配的老页面无效。
            -   修改分区的INITRANS属性，会同步修改该分区的所有子分区的INITRANS。

        -   _**storage\_alter\_clause**_

            表的存储空间的最大值。

            -   **UNLIMITED**

                表示不限制表存储空间的最大值。

            -   **_integer _\[K | M | G | T\]**

                设置表的存储空间最大值，取值范围是\[1M, 1T\]。

    -   **_enable\_disable\_clause_**

        启用或禁用约束，并指定启用或禁用约束时是否确保已有记录符合约束。

        -   ENABLE：启用约束。
        -   DISABLE：禁用约束。
        -   VALIDATE：启用或禁用约束时以及约束被启用或禁用后，确保已有数据符合约束。
        -   NOVALIDATE：启用或禁用约束时以及约束被启用或禁用后，不考虑已有数据是否符合约束。

        使用VALIDATE或NOVALIDATE，对新增记录和所更新的记录没有影响。也就是说，无论是使用VALIDATE还是使用NOVALIDATE，在使用ENABLE启用约束后都会检查新增记录和所更新的记录是否符合约束，但是在使用DISABLE禁用约束后则都不再检查新增记录和所更新的记录是否符合约束。

        使用VALIDATE或NOVALIDATE会对已有记录产生影响。也就是说，在启用或禁用约束时以及约束被启用或禁用后，如果使用VALIDATE，则会检查已有记录是否符合约束，如果不符合，则启用或禁用约束失败或新增修改记录时返回错误信息；使用NOVALIDATE，在启用或禁用约束时以及约束被启用或禁用后，则不会检查已有记录是否符合约束。

        使用ENABLE启用约束时，如果不指定使用NOVALIDATE，则默认使用VALIDATE，效果等同于ENABLE VALIDATE，检查已有记录、新增或修改的记录是否都符合约束；指定NOVALIDATE，则允许已有记录不必符合约束，但新增或修改的记录必须满足约束。

        使用DISABLE禁用约束时，如果不指定使用VALIDATE，则默认使用NOVALIDATE，效果等同于DISABLE NOVALIDATE，禁用约束，删除约束上的索引，且允许修改被约束的记录；指定VALIDATE，则禁用约束，删除约束字段上的索引，且不允许修改任何被约束的记录。

        快速了解\{ ENABLE | DISABLE \} \[VALIDATE | NOVALIDATE\]的组合特性，请参见[表1](#table13405522833)。

        **表 1**  关键字组合说明

|关键字组合|是否检查已有记录符合约束|是否检查新增或修改记录符合约束|
|--|--|--|
|ENABLE VALIDATE|yes|yes|
|ENABLE NOVALIDATE|no|yes|
|DISABLE VALIDATE|yes|no|
|DISABLE NOVALIDATE|no|no|


    -   **\[ PARTITION | SUBPARTITION \] NOLOGGING**

        -   NOLOGGING：启用或者禁用表上的Nologging Insert属性。
        -   PARTITION  NOLOGGING：启用或者禁用分区上的Nologging Insert属性。
        -   SUBPARTITION  NOLOGGING：启用或者禁用子分区上的Nologging Insert属性。

        表上的Nologging Insert属性与分区上的相互独立，某个分区是否具有Nologging Insert属性与表上的此属性无关，只取决于自身的Nologging Insert属性；父子分区间的Nologging属性具有关联性，如果父分区打开Nologging Insert属性，那么他的所有子分区也打开该属性，但是反过来子分区的Nologging Insert属性是否打开不影响父分区的此属性。

        Nologging Insert属性是一种特殊的操作，它是指在INSERT数据时不记录redo和undo日志，以提升insert的性能。由于此特性不记录redo和undo，请谨慎使用。该特性使用时，需要注意以下约束：

        -   数据库执行Nologging Insert只允许在数据入库阶段，此阶段只能有Insert操作，不允许同时存在其他数据修改操作。数据入库完毕后，开始正常业务前要关闭表或者分区的Nologging属性，不允许再执行Nologging的操作。
        -   由于不记录Redo，备机无法通过Redo重演出主机数据，因此不能在主备环境上开启Nologging Insert。
        -   数据库开启PCN校验时不支持Nologging Insert。
        -   开启逻辑复制开关的情况下不允许再开启Nologging Insert。
        -   如果数据库中有表或者分区对象存在Nologging Insert，则不允许动态添加备机。
        -   由于没有Redo/Undo，所以一旦发生任何异常，数据库均不能继续保证数据一致性，因此需要删除表数据，重新执行导入操作，如果继续在原来数据基础上跑业务可能发生数据库coredump等严重问题。
        -   临时表不支持Nologging Insert属性的设置，Nologging表本身就带有不记录Redo的属性，所以它也不支持再设置Nologging属性。
        -   Session级的Nologging与表分区级的Nologging相容，两者只要有一个打开，执行的就是Nologging Insert的流程。
        -   表上或者任意一个分区开启了Nologging Insert，则该表上只允许Insert操作以及与Insert类似的操作，由于没有undo，所以Nologging表或者分区数据没有MVCC机制，并发的select查询会报错，同时其他的DML或者修改表结构与表数据的DDL操作也不允许执行。
        -   表上或者分区上原本有数据的情况下，不允许开启Nologging Insert。
        -   由于没有undo，所以对于任何Nologging Insert的结果，数据一旦插入错误，只能重新插入，不能通过rollback回退到某一个历史时刻。
        -   支持表分区级Nologging Insert特性的版本不允许向不支持表分区级Nologging Insert特性的版本降级，但可以升级；如果两个版本都支持Nologging Insert特性，则可正常进行升级或降级操作（不考虑其他特性的影响）。升级或降级前需要用户手动确认数据库系统中是否存在Nologging对象，如果这些对象不再需要Nologging属性，建议关闭Nologging属性后再进行升级或降级操作。
        -   如果没有关闭对象的Nologging Insert属性进行备份恢复操作，会造成Nologging属性扩散到恢复的新环境上，用户需要确保这个属性扩散是否需要，如不需要需在备份前关闭对象的Nologging属性。

-   _**set\_interval\_clause**_

    设置间隔分区。仅对分区表有效。

    -   **SET INTERVAL\(\)**：将间隔分区表修改为范围分区表。
    -   **SET INTERVAL\(_interval\_value_\)**：修改间隔分区表的间隔值。

-   _**rename\_column\_clause**_

    修改表名。只能修改自己schema下的表名，不能修改系统表空间下的表名。

-   _**logic\_replication\_clauses**_

    打开表逻辑复制开关或者关闭逻辑复制开关，支持表级和表分区级逻辑复制开关。

    -   **_（sub）partition\_name_\[ , ... \]**

        在表名之后括号内添加表（子）分区名即为设置表分区级逻辑复制开关，支持多次补充未打开表分区开关，不支持表级和表分区级直接切换。

        SYS用户不会加载数据字典，因此SYS用户不支持多次补充打开表分区逻辑复制开关。

    -   **ADD LOGICAL LOG\(UNIQUE  _index\_name_\)**

        根据唯一索引打开表逻辑复制开关。

        -   **_index\_name_**

            唯一索引名称。

    -   **ADD LOGICAL LOG\(PRIMARY  KEY\)**

        根据主键打开表逻辑复制开关。

    -   **DROP LOGICAL LOG**

        关闭表级和分区级逻辑复制开关。

**示例<a name="section1079432672812"></a>**

-   添加列。

    ```
    --删除表training。
     DROP TABLE IF EXISTS training;
    --创建表training。 CREATE TABLE training(staff_id INT NOT NULL, course_name VARCHAR(50), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT);
    --添加列full_masks。
     ALTER TABLE training ADD full_masks INT;
    ```

-   删除列。

    ```
    ALTER TABLE training DROP score;
    ```

-   修改列的数据类型。

    ```
    ALTER TABLE training MODIFY course_name VARCHAR(20);
    ```

-   添加约束。

    ```
     ALTER TABLE training ADD CONSTRAINT ck_training CHECK(staff_id>0);
     ALTER TABLE training ADD CONSTRAINT uk_training UNIQUE(course_name);
    ```

-   重命名约束。

    ```
     ALTER TABLE training  RENAME CONSTRAINT ck_training TO ck_new_training;
     ALTER TABLE training  RENAME CONSTRAINT uk_training TO uk_new_training;
    ```

-   删除约束。

    ```
    ALTER TABLE training DROP CONSTRAINT uk_new_training;
    ```

-   重命名表。

    ```
    ALTER TABLE training RENAME TO training_2018;
    ```

-   删除分区training3和training4。

    ```
    --删除表training。
     DROP TABLE IF EXISTS training;
    --创建分区表training。 CREATE TABLE training(staff_id INT NOT NULL, course_name CHAR(20), course_period DATETIME, exam_date DATETIME, score INT)
     PARTITION BY RANGE(staff_id)
     (
     PARTITION training1 VALUES LESS THAN(100),
     PARTITION training2 VALUES LESS THAN(200),
     PARTITION training3 VALUES LESS THAN(300),
     PARTITION training4 VALUES LESS THAN(400)
     );
    --删除分区training3。
     ALTER TABLE training DROP PARTITION training3;
     --清空分区training4。
     ALTER TABLE training TRUNCATE PARTITION training4;
    ```

-   添加分区training5和training6。

    ```
    --添加分区training5。
     ALTER TABLE training ADD PARTITION training5 VALUES LESS THAN(450);
     --添加分区training6。
     ALTER TABLE training ADD PARTITION training6 VALUES LESS THAN(MAXVALUE);
    ```

-   分裂分区。

    ```
    --分裂分区training5
     ALTER TABLE training SPLIT PARTITION training5 AT(420) INTO (PARTITION p1, PARTITION p2);
    ```

-   添加联合主键约束。

    ```
    --删除表。 
    DROP TABLE IF EXISTS TRAINING_BASE;
    --创建表。
      CREATE TABLE TRAINING_BASE(
      id int,
      class varchar(8),
      name varchar2(8),
      gender boolean,
      score number(10, 5)
     ); 
    --添加联合主键约束。
     ALTER TABLE TRAINING_BASE ADD CONSTRAINT pk_tbl_base PRIMARY KEY (id, name);
    ```

-   打开或关闭表级逻辑复制开关。

    ```
    --删除表。
     DROP TABLE IF EXISTS logic_test;
    --创建表logic_test。 CREATE TABLE logic_test(staff_id INT PRIMARY KEY, course_name VARCHAR(50), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT);
    --打开逻辑复制开关。
     ALTER TABLE logic_test ADD LOGICAL LOG(PRIMARY KEY);
    --关闭逻辑复制开关。
     ALTER TABLE logic_test DROP LOGICAL LOG;
    ```

-   打开或关闭表分区级逻辑复制开关。

    ```
    --删除表。
     DROP TABLE IF EXISTS logic_test;
    --创建分区表logic_test。 CREATE TABLE logic_test(
      staff_id INT PRIMARY KEY,
      course_name VARCHAR(50),
      course_start_date DATETIME,
      course_end_date DATETIME,
      exam_date DATETIME,
      score INT)
     PARTITION BY RANGE(staff_id)( 
     PARTITION P1 VALUES LESS THAN (10),
     PARTITION P2 VALUES LESS THAN (20),
     PARTITION P3 VALUES LESS THAN (30),
     PARTITION P4 VALUES LESS THAN (40));
    --打开表分区级逻辑复制开关。
     ALTER TABLE logic_test(P1,P2) ADD LOGICAL LOG(PRIMARY KEY);
     ALTER TABLE logic_test(P3,P4) ADD LOGICAL LOG(PRIMARY KEY);
     --删除表分区的同时会删除表分区级逻辑复制开关。
     ALTER TABLE logic_test DROP PARTITION P3; ALTER TABLE logic_test DROP PARTITION P4;
    --关闭逻辑复制开关。
     ALTER TABLE logic_test DROP LOGICAL LOG;
    ```

-   修改表的分区的MAXSIZE值。

    ```
    --删除表。
     DROP TABLE IF EXISTS TEST_STORAGE;
    --创建表TEST_STORAGE,初始大小是1M，最大值是3M。
     CREATE TABLE TEST_STORAGE(C_ID INT, C_CHAR1 VARCHAR2(4000)) STORAGE (MAXSIZE 3M INITIAL 1M)
     PARTITION BY RANGE (C_ID )  (
     PARTITION PART1 VALUES LESS THAN (2) STORAGE (MAXSIZE 3M INITIAL 2M),
    PARTITION PART2 VALUES LESS THAN (3)
     );
    --修改表的存储空间的MAXSIZE值。
     ALTER TABLE TEST_STORAGE STORAGE (MAXSIZE 3M);
    --添加分区，初始大小是2M最大值是3M。
     ALTER TABLE TEST_STORAGE ADD PARTITION PART3 VALUES LESS THAN (4) STORAGE (MAXSIZE 3M INITIAL 2M);
    --修改PART1分区的最大值为2M。 ALTER TABLE TEST_STORAGE MODIFY PARTITION PART1 STORAGE (MAXSIZE 2M);
    ```

-   修改表及表分区的INITRANS值。

    ```
    --删除表。
     DROP TABLE IF EXISTS TEST_INITRANS;
    --创建表TEST_INITRANS。
     CREATE TABLE TEST_INITRANS(C_ID INT, C_CHAR1 VARCHAR2(4000)) INITRANS 2
     PARTITION BY RANGE (C_ID )  (
     PARTITION PART1 VALUES LESS THAN (2) INITRANS 5,
     PARTITION PART2 VALUES LESS THAN (3)
     );
    --修改表的INITRANS值。
     ALTER TABLE TEST_INITRANS INITRANS 10;
    --修改表的分区的INITRANS值。
     ALTER TABLE TEST_INITRANS MODIFY PARTITION PART1 INITRANS 20;
    ```

## ALTER USER<a name="ZH-CN_TOPIC_0000001835225633"></a>

**功能描述<a name="section15482165152815"></a>**

修改一个已经存在的数据库用户。

**注意事项<a name="section12761515162810"></a>**

-   执行该语句的用户需要有ALTER USER系统权限。
-   密码修改权限策略如下：
    -   用户修改自己的密码无需授予ALTER USER系统权限，修改其他用户的密码需要被授予ALTER USER系统权限。
    -   普通用户拥有ALTER USER系统权限可修改除DBA角色和SYS用户之外其他所有用户的密码。
    -   DBA角色的用户可以修改除SYS用户之外其他所有用户的密码。
    -   SYS用户可以修改所有用户密码。

-   如果指定的用户不存在，会提示错误信息：user \*name\* does not exist。
-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section156461206287"></a>**

```
ALTER USER user_name
    {   IDENTIFIED BY new_password  [ REPLACE old_password ]
      | PASSWORD EXPIRE
      | ACCOUNT { LOCK | UNLOCK }
      | PROFILE profile_name
      | DEFAULT TABLESPACE tablespace_name
     } [ ... ]
```

**参数说明<a name="section92703258283"></a>**

-   _**user\_name**_

    待修改的用户名。

-   **IDENTIFIED BY**

    固定值，用来指定新密码。

-   **_new\_password_**

    修改用户新密码。

    设置用户密码时，需要遵循如下规范：

    -   密码长度必须大于等于其对应的profile中PASSWORD\_MIN\_LEN参数限定的密码长度最小值，小于等于64个字符。
    -   同时修改用户密码，用户对应的profile文件，则密码的最小长度限制以要修改的profile中PASSWORD\_MIN\_LEN参数值为限制。
    -   若密码不以单引号括起来，则密码首字符必须是字母、\#号或下划线。
    -   密码不能与用户名或者用户名的倒序相同（校验时，不区分大小写）。
    -   密码只能包含以下4种类型，并且至少选取其中3种类型的组合。
        -   数字。
        -   小写字母。
        -   大写字母。
        -   空格或特殊字符（Cantian引擎支持的特殊字符列表，请参见[表1](#table73215532820)）。

    -   创建密码时，若密码中包含\_\#$以外的特殊字符或者空格，则密码须用单引号括起来。
    -   新密码与旧密码至少在两个字符位上有不同。例如，"abc"和"abd"只有一个字符位不同，而"abc"和"ABc"有两个字符位不同。
    -   若创建的密码中包含特殊字符$，通过ctsql连接数据库时必须使用\\转义字符转义，否则会登录失败。

-   **REPLACE  _old\_password_**
    -   不指定**REPLACE**关键字，即不会校验老密码，可直接修改密码。
    -   指定**REPLACE**关键字，系统会校验旧密码，需输入正确的原密码。
    -   指定**REPLACE**关键字，系统不会校验旧密码长度。

-   **PASSWORD EXPIRE**

    手动密码过期，过期后该用户登入提示“the password has expired”。

    当客户端是ctsql时，密码过期的账户在登录时会出现修改密码的交互式窗口，强制修改该用户密码。

    -   密码修改成功，进入连接。
    -   密码修改失败，退出交互式窗口。
    -   其余类型客户端，直接报错退出。

-   **ACCOUNT \{ LOCK | UNLOCK \}**
    -   **LOCK**

        手动锁定用户，禁止登录。锁定后该用户登入提示：

        ```
        the account is locked
        ```

    -   **UNLOCK**

        给用户解锁，允许登录。

-   **_profile\_name_**

    档案名。

    用户引用一个profile，profile必须提前创建并配置。用户引用的default profile时，格式为“DEFAULT”。

-   **DEFAULT TABLESPACE**

    用来指定用户表空间。

-   _**tablespace**_**_\_name_**

    表空间名称。

    **表 1**  特殊字符

|编号|字符|编号|字符|编号|字符|编号|字符|
|--|--|--|--|--|--|--|--|
|1|`|9|&|17|\|25|"|
|2|~|10|*|18|||26|,|
|3|!|11|(|19|[|27|<|
|4|@|12|)|20|{|28|.|
|5|#|13|-|21|}|29|>|
|6|$|14|_|22|]|30|/|
|7|%|15|=|23|:|31|?|
|8|^|16|+|24|'|-|-|


**示例<a name="section1079432672812"></a>**

-   创建用户user\_test，密码是Test@123\_old。

    ```
    CREATE USER USER_TEST IDENTIFIED BY 'Test@123_old';
    ```

-   修改用户user\_test的密码为Test@123\_new。

    ```
    ALTER USER USER_TEST IDENTIFIED BY 'Test@123_new' REPLACE 'Test@123_old';
    ```

-   手动锁定用户user\_test。

    ```
    ALTER USER USER_TEST ACCOUNT LOCK;
    ```

-   手动解锁用户user\_test。

    ```
    ALTER USER USER_TEST ACCOUNT UNLOCK;
    ```

-   手动密码过期。

    ```
    ALTER USER USER_TEST PASSWORD EXPIRE;
    ```

## COMMENT ON<a name="ZH-CN_TOPIC_0000001788466464"></a>

**功能描述<a name="section12528622132112"></a>**

使用comment语句在字典中增加一个关于表、视图或列的注释信息。

通过MY\_TAB\_COMMENTS、ADM\_TAB\_COMMENTS或MY\_COL\_COMMENTS、ADM\_COL\_COMMENTS系统视图可以查看注释信息。

**注意事项<a name="section43952717212"></a>**

-   为自己的表增加注释时，不需要权限；为任意用户的表增加注释时，需要执行语句的用户拥有COMMENT ANY TABLE权限。
-   支持创建表时，指定列的comment信息。
-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section8807732132120"></a>**

```
COMMENT ON {   TABLE [ schema_name. ] { table_name | view_name }
               | COLUMN [ schema_name. ] { table_name. | view_name. } column_name
            } IS 'string'
```

**参数说明<a name="section1094244210216"></a>**

-   **\[_ schema\_name_. \]**

    用户名。不指定时默认是当前登录用户。

-   **\{  _table\_name_  |  _view\_name_  \}**

    指定注释的表或视图名。

-   **\[_schema\_name_.\] \{  _table\_name_. |  _view\_name_. \}  _column\_name_**

    指定注释的列名。

-   **IS**

    指定注释内容。

-   **_string_**

    注释内容。

    最大长度4000字节。

**示例<a name="section20942746162112"></a>**

```
--删除表training。
DROP TABLE IF EXISTS training;
```

```
--创建表training。 
CREATE TABLE training(staff_id INT NOT NULL, course_name VARCHAR(50), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT);
```

```
--给表training添加注释。 
COMMENT ON TABLE training IS 'table of training courses';
```

```
--给列staff_id添加注释。
COMMENT ON COLUMN training.staff_id  IS 'id of staffs taking training courses';
```

## COMMIT<a name="ZH-CN_TOPIC_0000001835225677"></a>

**功能描述<a name="section239314742411"></a>**

该语句使当前事务工作单元中的所有操作“永久化”，并结束该事务。

**注意事项<a name="section7229953102411"></a>**

Cantian引擎中的数据操作（[INSERT](INSERT.md)、[UPDATE](UPDATE.md)）提交是默认关闭的，会话退出时，需要显式COMMIT，否则记录将丢失。

**语法格式<a name="section1665410113259"></a>**

```
COMMIT [ TRANSACTION | PREPARED XID | FORCE LTID ]
```

**参数说明<a name="section6101155182518"></a>**

-   **TRANSACTION**

    可选关键字，用于增加语句可读性，等同于单独执行COMMIT操作。

-   **PREPARED** **_XID_**

    提交处于已完成第一阶段提交的全局事务分支。

    -   **XID**

        事务标示符。

        **XID**格式：点分字符串，其包括以下3部分：

        -   FORMAT ID：整型值，有效范围：\[0, 9223372036854775807\]。
        -   GLOBAL TRANSACTION ID：BASE16格式，长度小于等于128B。
        -   BRANCH ID：BASE16格式，长度小于等于128B。

-   **FORCE** **_LTID_**

    用于在故障修复时，提交因页面损坏而产生的无法回滚的本地事务。

    -   **_LTID_**

        点分字符串，其中格式为_SEG\_ID_._SLOT_._XNUM_，字段值可通过查询视图DV\_TRANSACTIONS中SEG\_ID、SLOT、XNUM字段获取。

**示例<a name="section91313852516"></a>**

创建表training，插入数据并更新数据，提交操作后结束该事务。

```
--删除表training。 
DROP TABLE IF EXISTS training;
```

```
--创建表training。 
CREATE TABLE training(staff_id INT NOT NULL, staff_name VARCHAR(16), course_name CHAR(20), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT);
```

```
--向表training中插入记录1。 
INSERT INTO training(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score) VALUES(10,'LIPENG','JAVA','2017-06-15 12:00:00','2017-06-20 12:00:00','2017-06-25 12:00:00',90); 
--向表training中插入记录2。 
INSERT INTO training(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score) VALUES(11,'CAOM','JAVA','2017-06-20 12:00:00','2017-06-25 12:00:00','2017-06-26 12:00:00',95); 
--更新记录2中的staff_name字段和course_name字段。 
UPDATE training SET staff_name='WANGPAN', course_name='INFORMATION SAFETY' WHERE staff_id=11; 
--提交事务。 
COMMIT;
```

## CREATE INDEX<a name="ZH-CN_TOPIC_0000001788626056"></a>

**功能描述<a name="section106542279128"></a>**

在指定的表上创建一个索引。索引可以用来提高数据库查询性能，但是不恰当的使用将导致性能下降。

**注意事项<a name="section726815316122"></a>**

-   普通索引不支持在CLOB、BLOB和IMAGE、数组类型的字段上创建索引。函数索引不支持在表达式的数据类型是CLOB、BLOB和IMAGE、数组数据类型的字段上创建索引，但是表达式中引用的字段可以是上述类型。
-   执行该语句的用户需要有CREATE INDEX、CREATE ANY INDEX系统权限，普通用户不可以创建系统用户对象。
-   组合索引字段不超过16个，索引键的最大存储长度（包含索引列的数据及内部存储开销）的上限如下：
    -   如果PAGE\_SIZE的参数值是8K时，上限为4058字节。
    -   如果PAGE\_SIZE的参数值超过8K时，上限为4095字节。

-   分区索引只能在分区表上创建，分区表上可以创建分区索引和全局索引。分区索引数与表分区数需一致，否则会报错。
-   支持创建下列函数索引，并且不支持把函数索引转成约束。
    -   支持创建UPPER，TO\_CHAR，SUBSTR，NVL，NVL2，TO\_DATE，TRUNC，TO\_NUMBER，LOWER，REGEXP\_INSTR，DECODE，REGEXP\_SUBSTR，CASE WHEN表达式的索引，这些函数中可以嵌套其他不在此列表中的函数，包括自定义函数，但是需要符合如下描述的约束条件。
    -   创建函数索引时需要满足的约束条件如下：
        -   函数的参数中必须引用表字段，且引用的字段个数只能有一个。
        -   本地临时表上不允许创建函数索引（全局临时表上允许创建）。
        -   函数表达式中不允许包含与环境相关的变量时。包括：ROWNUM，ROWID，ROWSCN，CURDATE，CURRENT\_DATE，SYSDATE，CURRENT\_TIMESTAMP，LOCALTIMESTAMP，NOW，SESSIONTIMEZONE，SYSTIMESTAMP，USER，UTC\_TIMESTAMP。
        -   创建函数索引后，不会同步创建约束。
        -   索引表达式中不能包含聚集函数、分析函数、子查询、绑定参数、prior表达式、connect by、group by、sys\_connect\_by\_path函数等带有聚集、分组、子查询性质的函数。

-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section141236181217"></a>**

```
CREATE [ UNIQUE ] INDEX [IF NOT EXISTS ] [ schema_name. ]index_name ON table_index_clause [ CRMODE { PAGE | ROW } ] [ PARALLEL n ]
```

-   _table\_index\_clause_  子句：

    ```
    [ schema_name. ]table_name ( { [function_name()]column_name [ ASC | DESC ] } [ ,... ] ) index_attributes
    ```

    -   _index\_attributes_  子句：

        ```
        [   
           [ physical_attributes_clause ]   
           [ TABLESPACE {tablespace_name} ]   
           [ index_partitioning_clauses ]  
           [ ONLINE ] 
        ]
        ```

        -   _physical\_attributes\_clause_  子句：

            ```
            INITRANS integer
            ```

        -   _index\_partitioning\_clauses_  子句：

            ```
            LOCAL [ ( { PARTITION partition_name [   TABLESPACE tablespace_name ]     
                                                 [  INITRANS integer ]
                                                 [  PCTFREE integer ]     
                                                 [ { SUBPARTITION subpartition_name  [ TABLESPACE tablespace_name ]     
                                                    }[, ... ]    
                                                 ] 
                       } [ , ... ]  
                     )  
                   ]
            ```

**参数说明<a name="section182201639181216"></a>**

-   **UNIQUE**

    创建唯一性索引，每次添加数据时检测表中是否有重复值。如果插入或更新的值会导致重复的记录时将生成一个错误。

    目前只有B-tree支持唯一索引。

-   **IF NOT EXISTS**

    创建索引时，如果索引已经存在，不做改动，直接返回成功。如果索引不存在，则创建新索引。

-   **\[_schema\_name_.\]**

    模式名，与表的模式名相同，可省略。

-   **_index\_name_**

    要创建的索引名。

-   **_table\_name_**

    要创建索引的表名，可以有用户修饰。

-   **function\_name\(\)**

    创建函数索引的函数名称。

-   **_column\_name_**

    表的列名（字段名）。

-   **ASC**

    指定按升序排序 （默认）。

-   **DESC**

    指定按降序排序。

    目前只支持升序建索引，DESC也是升序。

-   **INITRANS**

    指定该索引初始化数据块中事务槽的个数，取值范围是\[1,255\]。不指定时，SYS用户默认是2，非SYS用户使用INI\_TRANS参数的值。

-   **TABLESPACE  _tablespace\_name_**

    指定索引的表空间，如果没有声明则使用默认的表空间。

-   **_index\_partitioning\_clauses_**

    分区表局部索引。

-   **LOCAL**

    LOCAL是分区索引（本地索引），就是在所有每个区上单独创建索引，它能自动维护，在drop或truncate某个分区时不影响该索引的其他分区索引的使用。

-   **PCTFREE**

    必须保留的最小空间的比例，单位是百分比%，取值范围是 \[0-80\]。在索引创建时为索引块留下的剩余空间，这个剩余空间可以用来插入新的索引项。

-   **ONLINE**

    在线创建索引。

    普通创建索引作为DDL操作，会对表加排他锁，从而阻塞表上并发的UPDATE/DELETE/INSERT操作，影响系统表事务吞吐量，在线创建索引和在线重建索引功能旨在创建索引和重建索引过程中，对表加共享锁（仅在开始和结束阶段短暂地加排他锁），允许UPDATE/DELETE/INSERT操作并发执行，从而不影响在线业务的执行。

-   **CRMODE \{ PAGE | ROW \}**

    指定该索引的CR\_MODE，不指定时默认和表的CR\_MODE配置保持一致。

    -   CRMODE PAGE指定为页级MVCC模式。
    -   CRMODE ROW指定为行级MVCC模式。

-   **PARALLEL  _n_**

    指定创建索引时的并行度。

    -   _n_是并行度，取值范围是\[1, 64\]。
    -   指定ONLINE时不支持并行创建。
    -   临时表不支持并行创建索引。
    -   函数索引不支持并行创建。

**示例<a name="section14516114617121"></a>**

-   在普通表posts上在线创建索引。

    ```
    --删除表posts。 
    DROP TABLE IF EXISTS posts;
    ```

    ```
    --创建普通表posts。 
    CREATE TABLE posts(post_id CHAR(2) NOT NULL, post_name CHAR(6) PRIMARY KEY, basic_wage INT, basic_bonus INT);
    ```

    ```
    --创建索引idx_posts。
    CREATE INDEX idx_posts ON posts(post_id ASC, post_name);
    ```

-   在分区表education上创建分区索引。

    ```
    --删除表education。 
    DROP TABLE IF EXISTS education;
    ```

    ```
    --创建分区表education。 
    CREATE TABLE education(staff_id INT NOT NULL, highest_degree CHAR(8), graduate_school VARCHAR(64), graduate_date DATETIME, education_note VARCHAR(70)) 
    PARTITION BY LIST(highest_degree) 
    ( PARTITION doctor VALUES ('博士'), 
    PARTITION master VALUES ('硕士'), 
    PARTITION undergraduate VALUES ('学士') 
    );
    ```

    ```
    --向表education中插入记录1。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(10,'博士','西安电子科技大学','2017-07-06 12:00:00','211'); 
    --向表education中插入记录2。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(11,'博士','西北农林科技大学','2017-07-06 12:00:00','211和985'); 
    --向表education中插入记录3。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(12,'硕士','西北工业大学','2017-07-06 12:00:00','211和985'); 
    --向表education中插入记录4。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(15,'学士','西安建筑科技大学','2017-07-06 12:00:00','非211和985'); 
    --向表education中插入记录5。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(18,'硕士','西安理工大学','2017-07-06 12:00:00','非211和985'); 
    --向表education中插入记录6。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(20,'学士','北京师范大学','2017-07-06 12:00:00','211和985'); 
    --提交事务。 
    COMMIT;
    ```

    ```
    --创建分区索引。 
    CREATE INDEX idx_training ON education(staff_id ASC, highest_degree) LOCAL (PARTITION doctor, PARTITION master, PARTITION undergraduate); 
    --创建函数索引。 
    CREATE INDEX idx_func ON education(upper(graduate_school)); 
    CREATE INDEX idx_func_1 ON education(to_char(staff_id));
    ```

## CREATE TABLE<a name="ZH-CN_TOPIC_0000001788626068"></a>

**功能描述<a name="section4925439105720"></a>**

创建表。

**注意事项<a name="section633135925715"></a>**

-   如果是创建当前用户的表，用户需要被授予CREATE TABLE系统权限；如果是创建其他用户的表，用户需要被授予CREATE ANY TABLE系统权限，普通用户不可以创建系统用户对象。
-   需要足够的存储空间。
-   必须指定：表名、列名（数据类型、size）。
-   自增列只支持int和bigint类型，一个表只支持一个自增列，并且自增列必须是主键或者唯一索引。
-   字符集和row\_movement\_clause目前只支持SQL解析。
-   CHECK约束的字段数量最大支持16列。
-   带DISTRIBUTE BY关键字仅支持分布式场景，单机不生效。
-   创建外键时，如果不指定列，默认取父表的主键。如果父表无主键，则报错。
-   临时表中若包含BLOB字段，则该字段被定义为RAW\(8000\)；若包含CLOB字段，则被定义为VARCHAR\(8000 BYTE\)。
-   本地临时表，只支持ON COMMIT PRESERVE ROWS，表名必须以‘\#’字符开头，并且设置配置项LOCAL\_TEMPORARY\_TABLE\_ENABLED=TRUE，激活本地临时表特性。
-   全局临时表，支持事务级别临时表和会话级别临时表。
    -   ON COMMIT PRESERVE ROWS：定义会话级别临时表，当该会话结束时，临时表的数据将随着会话的结束而删除，但表结构仍然存在。
    -   ON COMMIT DELETE ROWS：定义事务级别临时表，当事务结束，临时表的数据将随着事务结束而删除，表结构仍然存在。
    -   如果不指定ON COMMIT \{ DELETE | PRESERVE \} ROWS子句，默认创建事务级别临时表。

**语法格式<a name="section118541348195915"></a>**

```
CREATE [[ GLOBAL ] TEMPORARY ] TABLE [ IF NOT EXISTS ][ schema_name.] table_name
    {   relational_properties
       | [ ( column_name [ DEFAULT expr [ ON UPDATE expr ] ] [ AUTO_INCREMENT ] [COMMENT 'string'] [COLLATE collation_name] [inline_constraint]
       | out_of_line_constraint  ) ] AS query
     }
    [ ON COMMIT { DELETE | PRESERVE } ROWS ]
    [ physical_properties ]
    [ TABLESPACE tablespace_name ]
    [ table_properties ]
    [ CRMODE { PAGE | ROW } ]
    [ NOLOGGING]
    [ COMPRESS ]
    table_distribute_clauses
```

-   _relational\_properties_  子句：

    AUTO\_INCREMENT和DEFAULT不能同时使用。

    ```
    ( {column_name datatype_name [ DEFAULT expr [ ON UPDATE expr ] ] [ AUTO_INCREMENT ] [ COMMENT 'string' ] [ COLLATE collation_name ] [ inline_constraint ]|[out_of_line_constraint]} [, ... ] )
    ```

    -   _inline\_constraint_  子句：

        临时表不能使用_references\_clause_  子句。

        同一个列字段不能同时使用PRIMARY KEY和UNIQUE。

        ```
        [ CONSTRAINT constraint_name ] {   [ NOT ] NULL
                                           | UNIQUE
                                           | PRIMARY KEY 
                                           | CHECK( expr )  
                                           | references_clause 
                                        }[...]
        ```

        -   _references\_clause_  子句：

            ```
            REFERENCES [ schema_name. ]object_table [( column_name )] [ON DELETE { CASCADE | SET NULL } ] 
            ```

    -   _out\_of\_line\_constraint_  子句：

        ```
        [ CONSTRAINT constraint_name ] {   UNIQUE( column_name [ , ... ] ) [ using_index_clause ]
                                          | PRIMARY KEY( column_name [ , ... ] ) [ using_index_clause ]
                                          | CHECK( expr )
                                          | FOREIGN KEY( column_name [ , ... ] ) references_clause_ex                                 }[ ,...]
        ```

        -   _using\_index\_clause_  子句：

            ```
            USING INDEX [   INITRANS integer
                           | TABLESPACE tablespace_name 
                           | LOCAL [ ( { PARTITION partition_name [   TABLESPACE tablespace_name 
                                                                     | INITRANS integer
                                                                     | PCTFREE integer 
                                                                     |( { SUBPARTITION subpartition_name [ TABLESPACE tablespace_name ]
                                                                        } [, ... ]
                                                                       )
                                                                   ]
                                       } [ , ... ]
                                       )
                                     ]
                           ] [ ...] 
            ```

        -   _references\_clause\_ex_  子句：

            ```
            REFERENCES [ schema_name. ]object_table_name [( column_name [ , ... ] )][ ON DELETE { CASCADE | SET NULL } ]
            ```

-   AS query子句:

    ```
    SELECT [SQL_CALC_FOUND_ROWS] [ DISTINCT ] expression
        [ [ AS ] name ] [ , ... ]
        [ FROM table_reference [ [AS]alias ] [ , ... ] ]
        [ WHERE { condition | [ NOT ] EXISTS ( correlated subquery ) } ]
        [ [START WITH condition ] CONNECT BY [ NOCYCLE ] [ PRIOR ] condition ]
        [ GROUP BY { column_name | number } [ , ... ] ]
        [ HAVING condition [ , ... ] ]
        [ { UNION [ ALL ] } select ]
        [ ORDER BY { column_name | number } [ ASC | DESC ] [ NULLS FIRST | NULLS LAST ] [ , ... ] ]
        [ LIMIT [ offset_expr, ] count_expr | LIMIT count_expr OFFSET offset_expr | OFFSET offset_expr [ LIMIT count_expr ] ]
    ```

-   _physical\_properties_  子句：

    ```
    {   segment_attributes_clause
        | ORGANIZATION EXTERNAL external_table_clause
        | FORMAT row_format_clause
    ```

    -   _segment\_attributes\_clause_  子句：

        TABLESPACE_ tablespace\_name_在临时表中使用时不支持指定到非临时表空间 。

        ```
        {   physical_attributes_clause
            |  TABLESPACE tablespace_name
          } [ ... ] 
        ```

        -   _physical\_attributes\_clause_  子句：

            临时表的创建不支持_physical\_attributes\_clause_子句，其中PCTFREE、INITRANS和MAXTRANS属性可以创建但不生效，_storage\_clause_子句不支持 。

            ```
            {   PCTFREE integer
               | INITRANS integer
               | MAXTRANS integer
               | storage_clause
             } [ ...]
            ```

            -   _storage\_clause_子句：

                ```
                STORAGE ( {  INITIAL integer [K | M | G | T]
                              |MAXSIZE { UNLIMITED | integer [K | M | G | T] }
                           } [ ...] )
                ```

    -   _external\_table\_clause_  子句：

        ```
        ( [ TYPE { LOADER | DATAPUMP } ] external_data_properties )
        ```

        -   _external\_data\_properties_  子句：

            ```
            DIRECTORY directory_name
            [ ACCESS PARAMETERS ( opaque_format_spec ) ]
             LOCATION location_name
            ```

            -   _opaque\_format\_spec_  子句：

                ```
                RECORDS DELIMITED BY records_delimiter FIELDS TERMINATED BY fields_terminator
                ```

    -   _row\_format\_clause_  子句：

        ```
        ( { ASF | CSF } )
        ```

-   _table\_properties_  子句：

    ```
    [ column_properties ]
    [ AUTO_INCREMENT [ = ] value ]
    [ AS subquery]
    ```

    -   _column\_properties_  子句：

        ```
        [ LOB_storage_clause ]
        [ APPENDONLY { ON | OFF } ]
        ```

        -   _LOB\_storage\_clause_  子句：

            ```
            LOB ( LOB_item ) STORE AS { [ ( LOB_parameters ) ] }
            ```

            -   _LOB\_parameters_  子句：

                ```
                [   TABLESPACE tablespace_name
                   | { ENABLE | DISABLE } STORAGE IN ROW
                  ][ ... ]
                ```

-   _table\_distribute\_clauses_  子句：

    ```
    DISTRIBUTE BY {   replication_definition
                      | hash_definition
                      | range_definition 
                      | list_definition
                      | REFERENCE [ref_schema_name.]ref_table_name
                   }
    ```

    -   _replication\_definition_  子句：

        ```
        REPLICATION [ ON GROUPID ( group_id [ , ... ] ) ]
        ```

    -   _hash\_definition_  子句：

        ```
        [CONSISTENT] HASH ( column_name [ , ... ] ) [ USING BASIC ][SLICE n] [ ON GROUPID ( group_id [ , ... ] ) ]
        ```

    -   _range\_definition_  子句：

        ```
        RANGE ( distribute_expression )
              ( { GROUPID group_id VALUES LESS THAN ( { value | MAXVALUE } ) } [ , ... ] ) 
        ```

    -   _list\_definition_  子句：

        ```
        LIST ( distribute_expression )
             ( { GROUPID group_id VALUES ( value_list ) } [ , ... ] )
        ```

        -   _distribute\_expression_  子句：

            ```
            {  column name
              | SUBSTR
            }
            ```

>![](public_sys-resources/icon-note.gif) **说明：** 
>带DISTRIBUTE BY关键字仅支持分布式场景，单机不生效。

**参数说明<a name="section177531945105"></a>**

-   **GLOBAL**

    创建全局表。

-   **TEMPORARY**

    创建临时表。

-   **IF NOT EXISTS**

    创建表时，如果表已经存在，则不做改动直接返回；如果表不存在，则创建新表。

-   **\[_schema\_name_.\]_table\_name_**

    表名，不能和用户下表重名。本地临时表的名字需要用字符“\#”开头。创建本地临时表时，不使用GLOBAL参数，且需要将参数LOCAL\_TEMPORARY\_TABLE\_ENABLED的值设为TRUE。

    -   表名中不允许包含特殊字符分号（;）、竖线（|）、反引号（\`）、位运算（ &）、大于号（\>）、小于号（<）、双引号（"）、单引号（'）、感叹号（！）、@、空格和版权符号（©）。
    -   若表名中必须包含以上特殊字符及禁止特殊字符以外的其他特殊字符，必须用双引号（""）或者反引号（\`\`）括起来。
    -   其中表名中即使用双引号或者反引号括起来，也不推荐包含特殊字符双引号（"）、单引号（'）。

-   **_relational\_properties_**

    表属性，包括列名、类型、行内约束和行外约束。

    -   列名中不允许包含特殊字符分号（;）、竖线（|）、反引号（\`）、位运算（ &）、大于号（\>）、小于号（<）、双引号（"）、单引号（'）、感叹号（！）、@、空格和版权符号（©）。
    -   若列名中必须包含以上特殊字符及禁止特殊字符以外的其他特殊字符，必须用双引号（""）或者反引号（\`\`）括起来。
    -   其中列名中即使用双引号或者反引号括起来，也不推荐包含特殊字符双引号（"）、单引号（'）。

-   **DEFAULT  _expr_  \[ON UPDATE_ expr_\]**

    列默认值支持表达式，在创建DDL时，如果DEFAULT是常量表达式会向列类型做兼容检查。

    -   \[on update expr\] 是兼容语法，UPDATE行数据，不指定该列，取update默认值填充。
    -   insert和update default expr最大长度为1024英文字符长度，default后面的文本超过最大长度将会报错“CT-00611, default value string is too long, exceed 1024.”。

-   **AUTO\_INCREMENT**

    指定自增列。

    -   如果把一个NULL插入到一个AUTO\_INCREMENT数据列里去，Cantian引擎将自动生成下一个序列编号。编号从1开始，并1为基数递增。
    -   把0插入AUTO\_INCREMENT数据列的效果与插入NULL值一样。但不建议这样做，还是以插入NULL值为好。
    -   当插入记录时，没有为AUTO\_INCREMENT明确指定值，则等同插入NULL值。
    -   当插入记录时，如果为AUTO\_INCREMENT数据列明确指定了一个数值，则会出现两种情况。
        -   情况一，如果插入的值与已有的编号重复，则会出现报错信息，因为AUTO\_INCREMENT数据列的值必须是唯一的。
        -   情况二，如果插入的值大于已编号的值，则会把该插入到数据列中，并使在下一个编号将从这个新值开始递增。也就是说，可以跳过一些编号。

    -   如果用UPDATE命令更新自增列，如果列值与已有的值重复，则会出错。如果大于已有值，则下一个编号从该值开始递增。
    -   自增列增长到0x7FFFFFFFFFFFFFFF，为防止出现溢出，自增值一直为0x7FFFFFFFFFFFFFFF。

-   **COMMENT_ 'string'_**

    指定列的注释，通过MY\_COL\_COMMENTS系统视图查看。

-   **COLLATE  _collation\_name_**

    定义排序的规则。排序规则就是当比较两个列的数据时，根据某种规则来确定哪个比较大，是否相等。

    _collation\_name_取值如下：

    -   UTF8\_BIN：适用UTF-8字符集，将所有字符看作二进制串，然后从最高位往最低位比对。区分大小写。
    -   UTF8\_GENERAL\_CI：适用UTF-8字符集，不区分大小写。
    -   UTF8\_UNICODE\_CI：适用UTF-8字符集，不区分大小写。
    -   GBK\_BIN：适用GBK字符集，区分大小写。
    -   GBK\_CHINESE\_CI：适用GBK字符集，不区分大小写。

-   **_inline\_constraint_**

    列约束，作为列定义的一部分，现支持\[NOT\] NULL、UNIQUE、PRIMARY KEY、唯一索引、外键、check约束。

-   **_out\_of\_line\_constraint_**

    表约束，单独一行，支持UNIQUE索引、PRIMARY KEY、外键、CHECK约束。

-   **\[ NOT \] NULL**

    是否允许该列值为空。

    -   **NOT NULL**：不允许该列值为空。
    -   **NULL**：允许该列值为空。

-   **UNIQUE**

    值唯一，允许为空，一个表可以多个列为UNIQUE。

-   **PRIMARY KEY**

    主键，建立索引，不能为空，一个表只能建立一个主键。

-   **CHECK\( expr \)**

    对列值校验。若列插入数据为NULL，则默认校验为TRUE。

-   **ON DELETE \{ CASCADE | SET NULL \}**

    该属性用于外键，参照外表发生删除时，本表级联变化。

    -   **CASCADE**

        本表删除。

    -   **SET NULL**

        本表设置为NULL。

-   **FOREIGN KEY**

    外键。

-   **INITRANS integer**

    事务表的初始大小。

-   **TABLESPACE tablespace\_name**

    指定表空间。在临时表中使用时不支持指定到非临时表空间。

-   **LOCAL**

    默认属性，创建本地索引。

-   **PARTITION partition\_name**

    分区表。

-   **SUBPARTITION  _subpartition\_name_**

    子分区名。

-   **SQL\_CALC\_FOUND\_ROWS**

    在查询语句中，获取总行数，等效于select count\(\*\) from，适用于分页程序查询。

-   **DISTINCT**

    去重复，支持单列去重或者多列联合去重复。

-   **\[ AS \] name**

    设置输出打印列别名。

-   **FROM table\_reference \[ \[AS\] alias \] \[ , ... \]**

    查询表。

    -   **table\_reference**

        查询的父表，若该表是包含LOB字段的临时表，则不允许使用行内行外存储语法。

    -   **\[AS\] alias**

        为方便联合查询，可以对表设置别名。

-   **WHERE \{ condition | \[ NOT \] EXISTS \( correlated subquery \)**

    条件表达式，对行进行筛选。

    **correlated subquery**

    相关子查询语句。

-   **START WITH condition  CONNECT BY \[ NOCYCLE \] \[ PRIOR \] condition**

    树形表数据的子查询语句。如果一个表包含树形结构的数据，可以使用本查询子句进行查询。

    -   **START WITH**

        遍历的起始条件，指定查询开始的数据行。

    -   **CONNECT BY**

        连接条件，用于指定父数据行和子数据行之间的关系，结合prior使用。

    -   **NOCYCLE**

        即使数据中存在CONNECT BY LOOP，NOCYCLE参数也会指示数据库从查询中返回行。

    -   **PRIOR**

        prior是一个一元操作符，和+、-符号具有相同优先级。prior放在等号的左边或者右边决定了检索是自下向上还是自上向下的。换句话说：prior跟父节点列parentid放在一起，就是往父结点方向遍历；prior跟子结点列subid放在一起，则往叶子结点方向遍历。

-   **GROUP BY \{ column\_name | number \} \[ , ... \]**

    根据属性进行分组，需要注意的是会先排序后分组。

    -   **column\_name**

        分组的属性列名称。

    -   **number**

        分组的属性列在表中的序号。

-   **HAVING condition \[ , ... \]**

    用来过滤由GROUP BY语句返回的记录集，condition指定了过滤的条件。

-   **\{ UNION \[ ALL \] \} select**

    UNION操作符用于合并两个或多个SELECT语句的结果集。如果不含ALL关键字，则会消去表中任何重复行。

    **ALL**

    含ALL关键字，不会消去表中任何重复行。

-   **ORDER BY \{ column\_name | number \} \[ ASC | DESC \] \[ NULLS FIRST | NULLS LAST \] \[ , ... \]**

    排序条件，根据**column\_name| number**排序。若不指定** \[ NULLS FIRST | NULLS LAST \]**选项，ASC默认为NULLS LAST， DESC默认为NULLS FIRST。

    -   **column\_name**

        排序的列名称。

    -   **number**

        排序的列序号。

    -   **ASC**

        升序排序。

    -   **DESC**

        降序排序。

    -   **NULLS FIRST**

    指定ORDER BY列中NULL值的排序位置， 该选项表示将包含NULL值的行排在最前面。

    -   **NULLS LAST**

    指定ORDER BY列中NULL值的排序位置，该选项表示将包含NULL值的行排在最后面。

-   **LIMIT \[ offset\_expr, \] count\_expr | LIMIT count\_expr OFFSET offset\_expr | OFFSET offset\_expr \[ LIMIT count\_expr \]**

    count和offset用于查询结果集的子集数据的限制条件。

    -   **offset\_expr**

        数据结果集起始位置的值。例如一个查询结果有100条，offset\_expr=10则从第10条开始返回。

    -   **count\_expr**

        需要返回结果集中的数据量，比如一个查询结果有100条，count\_expr=40则表示选取40条返回。

    -   **OFFSET**

        关键字，标识数据起始位置。

-   **ORGANIZATION EXTERNAL**

    创建外部表的语句，通常可以在驱动器指定目录下创建表，单行支持最大规格为8K且支持SELECT查询操作。外部表的所有列不支持lob类型数据。

-   **PCTFREE  _integer_**

    为一个块保留的空间百分比。当数据块的可用空间低于该空间百分比时，只能更新该数据块的数据，不能向该数据块插入新数据。取值范围是\[0,80\]，默认值是8。

-   **INITRANS**

    初始化数据块中事务槽的个数，取值范围是\[1,255\]。不指定时，SYS用户默认是2，非SYS用户使用INI\_TRANS参数的值。

-   **MAXTRANS**

    数据块中事务槽的最大值。

-   _**storage\_clause**_
    -   **INITIAL** **_integer _\[K | M | G | T\]**

        表的初始大小，默认一个表的初始都是一个EXTENT，可通过INITIAL来指定表的初始大小。取值范围是\[64K, 1T\]。

    -   **MAXSIZE** **\{ UNLIMITED |  _integer _\[K | M | G | T\] \}**

        表的存储空间的最大值。

        -   **UNLIMITED**

            表示不限制表存储空间的最大值。

        -   **_integer _\[K | M | G | T\]**

            设置表的存储空间最大值，取值范围是\[1M, 1T\]。

-   **TYPE \{ LOADER | DATAPUMP \}**

    数据库转换类型。

    -   **LOADER**

        文本转换。将外部文本文件当作数据来源，查询外表时从外部文件中读取数据显示给用户。

    -   **DATAPUMP**

        二进制转换。将数据库中的表导出到外部文件中，该类型暂不支持。

-   **DIRECTORY**

    外部表所在目录的目录名称，在创建外表前需要先创建一个目录对象。

-   **ACCESS PARAMETERS**

    转换参数。

-   **LOCATION**

    文件名称。

-   **_opaque\_format\_spec_**

    records\_delimiter、fields\_terminator创建外部表时指定表记录和表字段的分割符，records\_delimiter支持单字符或'newline'，fields\_terminator支持单字符。

-   **_table\_properties_**

    指定表属性。

-   **AUTO\_INCREMENT** **\[ = \] **_**value**_

    建表时可用“AUTO\_INCREMENT=n”选项来指定一个自增的初始值。

    不指定从1开始，指定从value开始。

-   **APPENDONLY \{ ON | OFF \}**

    -   APPENDONLY ON表示不同的线程在对同一张表插入时，会申请新的page做插入，而不会去使用未插满的page。这种情况下，页面锁等待时长减少，但page空间浪费较多。当把appendonly设置为ON的时候，使用不当将造成大量空间浪费。具体请参见[ALTER TABLE](ALTER-TABLE.md)。
    -   APPENDONLY OFF表示不同的线程在对同一张表插入时，会尽量插满page空间。这种情况下，等锁时间比较长。

    不指定时，默认为OFF。

-   _**table\_distribute\_clauses**_
    -   _**hash\_definition**_
        -   **\[CONSISTENT\] HASH**

            当指定**CONSISTENT**时，表示使用一致性HASH算法，该HASH算法支持按照分片方式扩容。全局临时表支持使用一致性HASH算法建表，但不支持扩容。

        -   **USING BASIC**

            使用基本的hash算法，通过直接对数字类型的列取模计算hash值。

        -   **SLICE **_**n**_

            指定分片个数，仅指定CONSISTENT HASH时才可使用。

            n取值范围\[0,16384\]，值为0时，表示默认以DN分组个数作为分片个数。

        -   _**group\_id**_

            指定被调用DN节点所属复制组ID的编号。

        -   **REFERENCE**

            指定分片规则所参考的表且和参考表的分片规则保持一致。分片规则包含分片类型、分片键字段，分片键值 以及_**group\_id**_列表。比如创建表A时使用REFERENCE B，则A表的分片规则将和B表的分片规则一致。

        -   _**ref\_schema\_name**_

            分片规则所参考的表所属用户名称。

        -   _**ref\_table\_name**_

            分片规则所参考的表名称。

            >![](public_sys-resources/icon-note.gif) **说明：** 
            >带DISTRIBUTE BY关键字仅支持分布式场景，单机不生效。

-   **AS  _subquery_**

    指定子查询，在创建表时将子查询返回的行插入到表中。

-   **LOB\_storage\_clause**
    -   **LOB \( LOB\_item \) STORE AS \{ \[ \( LOB\_parameters \) \]**

        指定lob字段单独segment储存，可以指定线行内存储和行外存储。目前存储层只支持行外存储。

    -   **LOB\_item**

        lob字段名称。

    -   **LOB\_parameters**

        lob字段存储参数。

        **\{ENABLE | DISABLE \} STORAGE IN ROW**

        行内存储和行外存储。

        -   **ENABLE**

            行内存储。

        -   **DISABLE**

            行外存储。

-   **CRMODE \{ PAGE | ROW \}**

    指定该表的CR\_MODE，不指定时默认取当前实例的CR\_MODE配置。

    -   CRMODE PAGE指定为页级MVCC模式。
    -   CRMODE ROW指定为行级MVCC模式。

-   **NOLOGGING**

    此关键字指定表为nologging table。nologging table与普通表的区别主要是不记录redo日志，由于日志量的减少，所以提高了性能，同时，由于没有redo日志，重启后无法重演恢复。适用于存放临时数据的场景。

    -   nologging table表数据不做恢复，数据库重启时，表定义保留，表数据清空。
    -   nologging table不支持flashback & recycle bin，不支持两阶段提交。
    -   nologging table的表定义支持主备复制，表数据不做主备复制。
    -   nologging table的表定义支持备份恢复，表数据不做备份。
    -   nologging table支持MVCC，支持rollback，支持普通表所支持的DDL和DML操作。
    -   nologging table只能放到nologging tablespace上。
    -   nologging table默认放到temp2，可指定nologging tablespace，nologging table的index同理。
    -   create table不指定nologging关键字，但是放到nologging tablespace上，就是nologging table。
    -   nologging分区表的所有分区，都必须在nologging tablespace上。

-   **FORMAT**

    指定row的格式， 不指定则为默认的ASF格式，ASF即为Aligned Stream Format，CSF即为Compact Stream Format，压缩流格式。CSF支持表级和一级分区级指定。

    -   不含二级分区的表和不含二级分区的一级分区支持指定CSF格式。
    -   含二级分区的表、含二级分区的一级分区和二级分区不支持指定CSF格式。
    -   一级分区表如果表指定为CSF格式，则一级分区均为CSF格式。
    -   一级分区表如果表为默认ASF格式，则一级分区可以指定为CSF格式，如果不指定则默认为ASF格式。
    -   本地临时表和全局临时表不支持CSF格式。

-   **COMPRESS**

    创建表为压缩属性的。此表的数据在落盘时会使用压缩算法进行压缩\(默认为ZSTD，LEVEL=9\)，来节约磁盘空间。

    -   仅支持用户创建的非加密的BITMAP表空间。
    -   NOLOGGING表不支持压缩。
    -   不支持临时表空间。
    -   创建压缩表后，需保证对应的表空间内同步创建压缩属性的文件，否则插入数据时会报错。
    -   仅支持一级分区，不支持二级分区。若一级分区未单独指定COMPRESS属性，则会继承父表的COMPRESS属性。

**示例<a name="section131120915117"></a>**

-   创建全局会话级临时表sections。

    ```
    --删除表sections。 
    DROP TABLE IF EXISTS sections;
    ```

    ```
    --创建表sections。 
    CREATE GLOBAL TEMPORARY TABLE sections 
    (
       section_id   NUMBER(4) not null,
       section_name VARCHAR2(30),
       manager_id   NUMBER(6),
       place_id     NUMBER(4)
     ) ON COMMIT PRESERVE ROWS;
    ```

    ```
    --插入数据1。 
    insert into  sections (section_id, section_name, manager_id, place_id)
    values (10, 'Administration', 200, 1700); 
    --插入数据2。 insert into  sections (section_id, section_name, manager_id, place_id)
    values (20, 'Marketing', 201, 1800); 
    --插入数据3。 insert into  sections (section_id, section_name, manager_id, place_id)
    values (30, 'Purchasing', 114, 1700); 
    --提交事务。 
    COMMIT;
    ```

    ```
    --去重显示place_id。 
    SELECT DISTINCT place_id FROM sections;
    ```

-   创建带AUTO\_INCREMENT列的表。

    ```
    --删除表employee。 
    DROP TABLE IF EXISTS employee;
    ```

    ```
    --创建表employee。 
    CREATE TABLE employee(staff_id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,first_name VARCHAR(10));
    ```

    ```
    --插入数据。 
    INSERT INTO employee VALUES (NULL, 'Bob');
    ```

    ```
    --查询表中数据 
    SELECT * FROM employee;
    
    STAFF_ID     FIRST_NAME
    ------------ ---------- 
    1            Bob
    1 rows fetched.
    ```

-   创建带外键的表。

    ```
    --删除表staffs_f和employeeinfo_f。 
    DROP TABLE IF EXISTS staffs_f; 
    DROP TABLE IF EXISTS employeeinfo_f;
    ```

    ```
    --创建员工基本信息表staffs_f。  
    CREATE TABLE  staffs_f
    (
        staff_id       NUMBER(6)    PRIMARY KEY,
        first_name     VARCHAR2(20),
        last_name      VARCHAR2(25),
        email          VARCHAR2(25),
        phone_number   VARCHAR2(20),
        graduated_name VARCHAR2(60)
    );
    ```

    ```
    --创建雇佣信息表employeeinfo_f。  
    CREATE TABLE employeeinfo_f
    (
        staff_id       NUMBER(6),
        employment_id  VARCHAR2(10) PRIMARY KEY,
        hire_date      DATE,
        salary         NUMBER(8,2),
        FOREIGN KEY (staff_id) REFERENCES staffs_f(staff_id)
    );
    ```

-   创建表education。

    ```
    --删除表education。 
    DROP TABLE IF EXISTS education;
    ```

    ```
    --创建表education。 
    CREATE TABLE education(staff_id INT, highest_degree CHAR(8) NOT NULL, graduate_school VARCHAR(64), graduate_date DATETIME, education_note VARCHAR(70));
    ```

-   创建表training。

    ```
    --删除表training。 
    DROP TABLE IF EXISTS training;
    ```

    ```
    --创建表training。 
    CREATE TABLE training 
    ( 
    staff_id INT NOT NULL,
    course_name VARCHAR(50),  
    course_start_date DATETIME, 
    course_end_date DATETIME,  
    exam_date DATETIME,  
    score INT 
    );
    ```

-   创建表privilege。

    ```
    --删除表privilege。 
    DROP TABLE IF EXISTS privilege;
    ```

    ```
    --创建privilege。 
    CREATE TABLE privilege(staff_id INT PRIMARY KEY, privilege_name VARCHAR(64) NOT NULL, privilege_description VARCHAR(64), privilege_approver VARCHAR(10));
    ```

-   创建包含BLOB字段和CLOB的临时表，被定义为RAW\(8000\)和VARCHAR\(8000\)。

    ```
    --创建表STAFFS。 
    CREATE  GLOBAL TEMPORARY  TABLE STAFFS
    ( 
    staff_id INT NOT NULL,
    course_name BLOB,  
    COMMENT  CLOB 
    );
    ```

    ```
    --查看STAFFS表。 
    DESC STAFFS; 
    Name                                Null?    Type 
    ----------------------------------- -------- ------------------------------------ 
    STAFF_ID                            NOT NULL BINARY_INTEGER 
    COURSE_NAME                                  RAW(8000) 
    COMMENT                                      VARCHAR(8000 BYTE)
    ```

-   创建appendonly表。

    ```
    --删除表。 
    DROP TABLE IF EXISTS tbl_base;
    ```

    ```
    --创建表。 
    CREATE TABLE tbl_base (  
     id int,  
     class varchar(8),  
     name varchar2(8),  
     gender boolean,  
     score number(10, 5) 
    ) APPENDONLY ON;
    ```

-   创建一个row format为csf的表。

    ```
    CREATE TABLE TEST_CSF 
    ( 
    c1 INT, 
    c2 VARCHAR(50) 
    ) 
    FORMAT CSF;
    ```

-   创建分区为row format为csf格式的分区表。

    ```
    --表中p1和p3分区row format为csf格式，p2分区row format为默认asf格式。 
    create table test_part_csf(id int, name varchar2(100)) PARTITION BY list(id)  
    ( 
    partition p1 values (1) format csf, 
    partition p2 values (2), partition p3 values (3) format csf ); 
    --表中p1、p2和p3分区row format均为csf格式。 
    create table test_part_csf(id int, name varchar2(100)) PARTITION BY list(id)  
    ( 
    partition p1 values (1), 
    partition p2 values (2), 
    partition p3 values (3) 
    ) format csf;
    ```

-   创建表TEST\_HASH，初始大小为128K，最大值是3M。

    ```
    --删除表。 
    DROP TABLE IF EXISTS TEST_HASH;
    ```

    ```
    --创建表。 
    CREATE TABLE TEST_HASH(C_ID INT NOT NULL, C_CHAR1 VARCHAR2(4000)) STORAGE(INITIAL 128K MAXSIZE 3M);
    ```

-   创建表privilege时添加注释。

    ```
    --删除表privilege。 
    DROP TABLE IF EXISTS privilege;
    ```

    ```
    --创建privilege。 
    CREATE TABLE privilege 
    (staff_id INT PRIMARY KEY COMMENT 'id of the staff granted privileges',   
    privilege_name VARCHAR(64) NOT NULL,   
    privilege_description VARCHAR(64),   
    privilege_approver VARCHAR(10));
    ```

## CREATE TABLESPACE<a name="ZH-CN_TOPIC_0000001835265621"></a>

**功能描述<a name="section4925439105720"></a>**

创建表空间。

**注意事项<a name="section633135925715"></a>**

-   执行该语句的用户需要有CREATE TABLESPACE系统权限。
-   不能将数据文件路径指定到数据库运行日志目录、归档日志目录等可能会被清理的目录下。
-   只能对用户表空间设置AUTOOFFLINE。
-   带SHARD关键字仅支持分布式场景，单机不生效。
-   普通用户创建对象及插入数据时，建议不要指定system表空间。
-   表空间中单个数据文件大小与PAGE\_SIZE取值有关，具体关系如下：
    -   undo表空间
        -   如果PAGE\_SIZE的默认值是8K，则单个数据文件大小的上限是32GB。
        -   如果PAGE\_SIZE的默认值是16K，则单个数据文件大小的上限是64GB。
        -   如果PAGE\_SIZE的默认值是32K，则单个数据文件大小的上限是128GB。

    -   其他表空间
        -   如果PAGE\_SIZE的默认值是8K，则单个数据文件大小的上限是8TB。
        -   如果PAGE\_SIZE的参数值是16K，则单个数据文件大小的上限是16TB。
        -   如果PAGE\_SIZE的参数值是32K，则单个数据文件大小的上限是32TB。

**语法格式<a name="section118541348195915"></a>**

```
CREATE [UNDO] TABLESPACE tablespace_name [ EXTENTS integer  ]  
   DATAFILE { datafile_tempfile_spec [, ... ] } [NOLOGGING] [autooffline_clause] [EXTENT AUTOALLOCATE][SHARD]
```

-   _datafile\_tempfile\_spec_  子句：

    ```
    'file_name' SIZE integer [ K | M | G ] [COMPRESS] [ autoextend_clause ]
    ```

    -   _autoextend\_clause_  子句：

        ```
        AUTOEXTEND {   OFF
                     | ON [ NEXT integer [ K | M | G ] ]        
                          [ MAXSIZE integer [ K | M | G ] | UNLIMITED ]
                   }
        ```

-   _autooffline\_clause_  子句：

    ```
    AUTOOFFLINE [ ON | OFF ]
    ```

**参数说明<a name="section177531945105"></a>**

-   **UNDO**

    创建UNDO表空间。

-   **_tablespace\_name_**

    表空间名称。不能和已有表空间名称重名，否则报错。

-   **EXTENTS** **_integer_**

    一个extent里包含的页面数。

    取值范围 : \[8, 1024\]，且必须为2的整数次幂。不指定EXTENTS时，默认一个extent包含8个页面。

    增大单个extent的页面数量可以提高IO性能，但如果表空间下存在小表（数据量未达到一个extent大小），会导致空间浪费。

-   **DATAFILE**

    数据文件。

-   **_datafile\_tempfile\_spec_**

    表空间数据文件，可以用逗号分隔多个数据文件，数据文件不支持中文。

    -   **_file\_name_**

        新生成的数据文件在操作系统下的路径＋新数据文件名。指定文件名为相对路径时，默认保存在数据目录的data目录下。

        >![](public_sys-resources/icon-note.gif) **说明：** 
        >如果配置的绝对路径为数据库安装用户$\{HOME\}定义之外的路径，为了预防表空间文件泄露，请将表空间存储目录以及父目录的属主和属组都设置为与数据库安装用户一致，并修改权限为700。

    -   **_SIZE integer_\[ K | M | G \]**

        数据文件大小。

        **K**：单位KB。

        **M**：单位MB。

        **G**：单位GB。

        undo表空间中单个数据文件的取值范围：\[128M,32G\]或\[128M,64G\]或\[128M,128G\]，system表空间和sysaux表空间中单个数据文件的取值范围：\[128M,8TB\]或\[128M,16TB\]或\[128M,32TB\]，其它表空间中单个数据文件的取值范围：\[1M,8TB\]或\[1M,16TB\]或\[1M,32TB\]，且均与PAGE\_SIZE取值有关。

    -   **COMPRESS**

        指定新增的数据文件为压缩属性。压缩文件用来存储压缩属性的表，当使用表压缩特性时，需要同步在对应表空间下创建压缩文件。

    -   **_autoextend\_clause_**

        表空间的AUTOEXTEND为on时，可以手动指定每次扩展的大小且表空间单个数据文件的上限大小和PAGE\_SIZE取值有关。

        -   不指定AUTOEXTEND字句，默认不自动扩展。
        -   指定AUTOEXTEND OFF，默认不自动扩展。
        -   指定AUTOEXTEND ON时，可设置的属性如下：
            -   “NEXT”指定自动扩展的大小。若用户未指定时，默认值为16MB。
            -   “MAXSIZE”指定数据文件自动扩展的上限。

            -   若用户既指定了上限值也通过“NEXT”指定了自动扩展大小，则指定的上限值不得小于用户指定的自动扩展值。

-   **NOLOGGING**

    指定TABLESPACE为NOLOGGING类型，该类型的表空间下的表为nologging table。nologging table只能放到nologging tablespace上。

    -   CREATE DATABASE默认创建表空间temp2， temp2\_undo，分别存放nologging table的数据和undo。
    -   全局只有一个nologging的undo区：temp2\_undo，不能删除temp2\_undo，不能重命名 temp2\_undo。
    -   可以创建多个nologging data tablespace。
    -   可以通过DV\_TABLESPACES显示nologging tablespace，其中temporary字段显示为true。

-   **_autooffline\_clause_**

    设置表空间是否开启自动离线。AUTOOFFLINE为ON时，开启自动离线的用户表空间，在数据库启动过程中存在文件打开失败的问题时，会自动离线该用户表空间；若用户表空间在数据库启动成功后出现问题，则不会自动离线。

-   **EXTENT AUTOALLOCATE**

    设置表空间类型为bitmap管理，在这个表空间上创建的对象，extent size自动扩展。在单表数据量较大的场景下，会有更好的IO性能。如果通过extents选项指定为定长extent size，那么就不能再指定此选项。可以通过DV\_TABLESPACES视图查看表空间的类型和extent size管理方式。

-   **SHARD**

    命令支持下发至所有CN和DN 节点，仅支持AUTOEXTEND ，AUTOPUEGE在所有分片生效。该关键词仅支持分布式场景，单机不生效。

**示例<a name="section131120915117"></a>**

-   创建表空间video\_space，大小为32M。

    ```
    CREATE TABLESPACE video_space DATAFILE '-video_dfile1' SIZE 32M;
    ```

-   创建表空间image\_space，一个extent包含128页。表空间大小为32M，数据插满32M时，表空间自动扩展，可手动指定每次扩展大小。

    ```
    CREATE TABLESPACE image_space EXTENTS 128 DATAFILE '-image_dfile1' SIZE 32M AUTOEXTEND ON NEXT 10M;
    ```

## CREATE TABLE PARTITION<a name="ZH-CN_TOPIC_0000001835265613"></a>

**功能描述<a name="section45776604211"></a>**

创建分区表。

分区表是把逻辑上的一张表根据某种方案分为几张物理块进行存储，这张逻辑上的表称之为分区表，物理块称之为分区。分区表是一张逻辑表，不存储数据，数据实际是存储在分区上的，普通用户不可以创建系统用户对象。

**背景信息<a name="section68114198318"></a>**

Cantian引擎支持范围分区（Range Partitioning）、哈希分区（Hash Partitioning）、列表分区（List Partitioning）、间隔分区（INTERVAL Partitioning）。

-   范围分区是根据表的一列或者多列，将要插入表的记录分为若干个范围，这些范围在不同的分区里没有重叠。为每个范围创建一个分区，用来存储相应的数据。

    范围分区策略：根据分区键值将记录映射到已创建的某个分区上，如果可以映射到已创建的某一分区上，则把记录插入到对应的分区上，否则给出报错和提示信息。这是最常用的分区策略。

-   哈希分区是指，数据库根据哈希算法映射行到用户指定的分区键中。行的存放目的地由数据库的内部哈希函数来决定。哈希算法的目的是在设备上均匀分布行。
-   列表分区明确指定了根据某字段的某个具体值进行分区，而不是像范围分区那样根据字段的值范围来划分的。
-   间隔分区策略：是范围分区的一种扩展。当插入记录时，如果可以映射到某一分区上，则把记录插入到对应的分区上，否则根据间隔分区策略自动创建分区，并把记录插入到新建的分区上。新建分区名前缀是\_SYS\_P。

分区可以提供若干好处：

-   某些类型的查询性能可以得到极大提升。特别是表中访问率较高的行位于一个单独分区或少数几个分区上的情况下，分区可以减少数据的搜索空间，提高数据访问效率。
-   当查询或更新一个分区的大部分记录时，连续扫描那个分区而不是访问整个表可以获得巨大的性能提升。
-   如果需要大量加载或者删除的记录位于单独的分区上，则可以通过直接读取或删除那个分区以获得巨大的性能提升。

**注意事项<a name="section764523714314"></a>**

-   如果是创建当前用户的表，用户需要被授予CREATE TABLE系统权限；如果是创建其他用户的表，用户需要被授予CREATE ANY TABLE系统权限，普通用户不可以创建系统用户对象。

创建分区表和创建普通表有所不同，存在一些不兼容的属性，如下：

-   分区键不能超过16个字段。
-   分区键支持如下数据类型：int、integer、bigint、number、decimal、real、 double、numeric、varchar、varchar2、char、binary、raw、date、datetime、 timestamp。
-   当前支持分区类型：RANGE、LIST、HASH、INTERVAL分区。
-   间隔分区（INTERVAL）最多支持4194304个，如果分区总数超出4194304个，则报错。
-   二级分区最大总数为4194304个，每一个一级分区下面最大支持4096个二级分区。

**语法格式<a name="section97644241418"></a>**

```
CREATE TABLE [ IF NOT EXISTS ][ schema_name. ]table_name
   [ relational_properties ]
   [ physical_properties ]
   [ TABLESPACE tablespace_name]
   [ table_properties ]
```

-   _relational\_properties _子句：

    AUTO\_INCREMENT和DEFAULT不能同时使用。

    ```
    { column_name datatype_name [DEFAULT expr [ ON UPDATE expr ]] [ AUTO_INCREMENT ]
                                [ COMMENT 'string' ] [ COLLATE collation_name ]
                                [ inline_constraint ] | [ out_of_line_constraint ]
    } [ , ... ]
    ```

    -   _inline\_constraint _子句：

        PRIMARY KEY和UNIQUE不能同时使用。

        ```
        [ CONSTRAINT constraint_name ] {   [ NOT ] NULL
                                         | UNIQUE
                                         | PRIMARY KEY
                                         | CHECK( expr )
                                         | references_clause
                                       }[...]
        ```

        -   _references\_clause _子句：

            ```
            REFERENCES [ schema_name. ]object_table_name ( column_name )[ ON DELETE { CASCADE | SET NULL } ]
            ```

    -   _out\_of\_line\_constraint _子句：

        ```
        [ CONSTRAINT constraint_name ] {   UNIQUE( column_name [ , ... ] ) [ using_index_clause ]
                                         | PRIMARY KEY( column_name [ , ... ] ) [ using_index_clause ]
                                         | CHECK( expr )
                                         | FOREIGN KEY( column_name [ , ... ] ) references_clause_ex
                                       }
        ```

        -   _using\_index\_clause _子句：

            ```
            USING INDEX
               [   INITRANS integer
                 | TABLESPACE tablespace_name
                 | LOCAL [ ( { PARTITION partition_name [   TABLESPACE tablespace_name
                                                          | INITRANS integer
                                                          | PCTFREE integer
                                                          |( { SUBPARTITION subpartition_name [ TABLESPACE tablespace_name ]
                                                             } [, ...]
                                                           )
                                                        ]
                             } [ , ... ]
                           )
                         ]
               ] [ ...]
            ```

        -   _references\_clause\_ex _子句：

            ```
            REFERENCES [ schema_name. ]object_table_name ( column_name [ , ... ] ) [ ON DELETE { CASCADE | SET NULL } ]
            ```

-   _physical\_properties _子句：

    ```
    { segment_attributes_clause
    
    }
    ```

    -   _segment\_attributes\_clause _子句：

        ```
        {   physical_attributes_clause
          | TABLESPACE tablespace_name
        } [ ... ]
        ```

        -   _physical\_attributes\_clause _子句：

            ```
            [   { PCTFREE integer
              | INITRANS integer
              | storage_clause
              } [ ...]
            ]
            ```

            -   _storage\_clause_子句：

                ```
                STORAGE ( {   INITIAL integer [K | M | G | T]
                            | MAXSIZE { UNLIMITED | integer [K | M | G | T] }
                          } [ ...] )
                ```

-   _table\_properties _子句：

    ```
    [ column_properties ]
    [ table_partitioning_clauses ]
    [ AUTO_INCREMENT [ = ] value ]
    ```

    -   _column\_properties _子句：

        ```
        [ LOB_storage_clause ]
        [ APPENDONLY { ON | OFF } ]
        ```

        -   _LOB\_storage\_clause _子句：

            ```
            LOB ( LOB_item ) STORE AS { LOB_segname [ ( LOB_parameters ) ] }
            ```

            -   _LOB\_parameters _子句：

                ```
                [   TABLESPACE tablespace_name
                  | { ENABLE | DISABLE } STORAGE IN ROW
                ] [ ... ]
                ```

    -   _table\_partitioning\_clauses _子句：

        ```
        {   range_partitioning
          | list_partitioning
          | hash_partitioning
          | interval_partitioning
        }
        ```

        -   _range\_partitioning _子句：

            ```
            PARTITION BY RANGE ( partition_key [ , ... ] )[ SUBPARTITION BY { RANGE | LIST | HASH } ( subpartition_key [, ... ] ) ]
                               ( { PARTITION partition_name VALUES LESS THAN ( {   partition_value
                                                                                 | MAXVALUE
                                                                               } [ , ... ]
                                                                             )
                                  [ TABLESPACE tablespace_name ] 
                                  [physical_attributes_clause]
                                  [ ( { SUBPARTITION subpartition_name [ { VALUES LESS THAN ( { partition_value | MAXVALUE } [, ... ] ) |
                                                                           VALUES ( { partition_value | DEFAULT } [, ... ] } ]
                                                                           [ TABLESPACE tablespace_name ]
                                       } [, ... ] ) ]
                                 } [ , ... ]
                               )
            ```

        -   _list\_partitioning _子句：

            ```
            PARTITION BY LIST ( partition_key [ , ... ] ) [ SUBPARTITION BY { RANGE | LIST | HASH } ( subpartition_key [, ... ] ) ]
                              ( { PARTITION partition_name VALUES ( partition_value [ , ... ]
                                                                   |[ DEFAULT ]
                                                                  )
                                  [ TABLESPACE tablespace_name ] 
                                  [ physical_attributes_clause ]
                                  [ ( { SUBPARTITION subpartition_name [ { VALUES LESS THAN ( { partition_value | MAXVALUE } [, ... ] ) |
                                                                           VALUES ( { partition_value | DEFAULT } [, ... ] } ] 
                                                                           [ TABLESPACE tablespace_name ]
                                       } [, ... ] ) ]
                                } [ , ... ]
                              )
            ```

        -   _hash\_partitioning _子句：

            ```
            PARTITION BY HASH ( partition_key [ , ... ] ) [ SUBPARTITION BY { RANGE | LIST | HASH } ( subpartition_key [, ... ] ) ]
                              {   ( { PARTITION partition_name
                                      [ TABLESPACE tablespace_name ] 
                                      [ physical_attributes_clause ]
                                      [ ( { SUBPARTITION subpartition_name [ { VALUES LESS THAN ( { partition_value | MAXVALUE } [, ... ] ) |
                                                                               VALUES ( { partition_value | DEFAULT } [, ... ] } ]
                                                                               [ TABLESPACE tablespace_name ]
                                           } [, ... ] ) ]
                                     } [ , ... ]
                                  )
                                | PARTITIONS partition_count [ STORE IN (tablespace_name [ , ... ]) ]
                              }
            ```

        -   _interval\_partitioning _子句：

            ```
            PARTITION BY RANGE ( partition_key ) INTERVAL ( interval_value ) [ SUBPARTITION BY { RANGE | LIST | HASH } (subpartition_key [, ...] ) ]
                               ( { PARTITION partition_name VALUES LESS THAN ( partition_value )
                                   [ TABLESPACE tablespace_name ] 
                                   [ physical_attributes_clause ]
                                   [ ( { SUBPARTITION subpartition_name [ { VALUES LESS THAN ( { partition_value | MAXVALUE } [, ... ] ) |
                                                                            VALUES ( partition_value | DEFAULT } [, ... ] } ]
                                                                            [ TABLESPACE tablespace_name ]
                                        } [, ... ] ) ]
                                  } [ , ... ]
                               )
            ```

**参数说明<a name="section1166251717360"></a>**

-   **IF NOT EXISTS**

    创建表时，如果表已经存在，则不做改动直接返回；如果表不存在，则创建新表。

-   **\[_schema\_name._\]table\_name**

    表名，不能和用户下表重名。

-   _**tablespace\_name**_

    某个范围分区的表空间。

    指定分区表的某个范围分区的表空间。

-   **_relational\_properties_**

    表属性，包括列名、类型、行内约束和行外约束。

-   **DEFAULT  _expr _\[ON UPDATE  _expr_\]**

    列默认值支持表达式，在创建DDL时，如果DEFAULT是常量表达式会向列类型做兼容检查。

    -   \[on update expr\] 是参考MYSQL语法，UPDATE行数据，不指定该列，取update默认值填充。
    -   insert和update default expr最大长度为1024英文字符长度，default后面的文本超过最大长度将会报错“CT-00611, default value string is too long, exceed 1024.”。

-   **AUTO\_INCREMENT**

    指定自增列。

    -   如果把一个NULL插入到一个AUTO\_INCREMENT数据列里去，Cantian引擎将自动生成下一个序列编号。编号从1开始，并1为基数递增。
    -   把0插入AUTO\_INCREMENT数据列的效果与插入NULL值一样。但不建议这样做，还是以插入NULL值为好。
    -   当插入记录时，没有为AUTO\_INCREMENT明确指定值，则等同插入NULL值。
    -   当插入记录时，如果为AUTO\_INCREMENT数据列明确指定了一个数值，则会出现两种情况，情况一，如果插入的值与已有的编号重复，则会出现出错信息，因为AUTO\_INCREMENT数据列的值必须是唯一的；情况二，如果插入的值大于已编号的值，则会把该插入到数据列中，并使在下一个编号将从这个新值开始递增。也就是说，可以跳过一些编号。
    -   如果用UPDATE命令更新自增列，如果列值与已有的值重复，则会出错。如果大于已有值，则下一个编号从该值开始递增。
    -   自增列增长到0x7FFFFFFFFFFFFFFF，为防止出现溢出，自增值一直为0x7FFFFFFFFFFFFFFF。

-   **COMMENT  _'string'_**

    指定列的注释，通过MY\_COL\_COMMENTS系统视图查看。

-   **COLLATE  _collation\_name_**

    定义排序的规则。

    当比较两个列的数据时，根据定义的排序规则来确定哪个比较大或是否相等。

    _collation\_name_取值如下：

    -   UTF8\_BIN：适用UTF8字符集，将所有字符看作二进制串，然后从最高位往最低位比对。区分大小写。
    -   UTF8\_GENERAL\_CI：适用UTF8字符集，不区分大小写。
    -   UTF8\_UNICODE\_CI：适用UTF8字符集，不区分大小写。
    -   GBK\_BIN：适用GBK字符集，区分大小写。
    -   GBK\_CHINESE\_CI：适用GBK字符集，不区分大小写。

-   _**inline\_constraint**_

    列约束，作为列定义的一部分，现支持\[NOT\] NULL、UNIQUE、PRIMARY KEY、唯一索引、外键、check约束。

-   **\[ NOT \] NULL**

    是否允许该列值为空。

    -   **NOT NULL**：不允许该列值为空。
    -   **NULL**：允许该列值为空。

-   **UNIQUE**

    值唯一，允许为空，一个表可以多个列为UNIQUE。

-   **PRIMARY KEY**

    主键，建立索引，不能为空，一个表只能建立一个主键。

-   **CHECK\( expr \)**

    对列值校验。

-   _**references\_clause**_

    添加外键约束。schema\_name表示所参考表的所有者，object\_table表示所参考的表。column\_name表示所参考的字段。

    父表不指定列，默认取父表的主键，如果父表的主键不存在，则报错。

-   **ON DELETE \{ CASCADE | SET NULL \}**

    该属性用于外键，参照外表发生删除时，本表级联变化。

    -   **CASCADE**

        本表删除。

    -   **SET NULL**

        本表设置为NULL。

-   **_out\_of\_line\_constraint_**

    表约束，单独一行，支持UNIQUE索引、PRIMARY KEY、外键、CHECK约束。

-   **FOREIGN KEY**

    外键。

-   **TABLESPACE tablespace\_name**

    指定表空间。

-   **LOCAL**

    默认属性，创建本地索引。

-   **PCTFREE  _integer_**

    为一个块保留的空间百分比。当数据块的可用空间低于该空间百分比时，只能更新该数据块的数据，不能向该数据块插入新数据。取值范围是\[0,80\]，默认值是 8。

-   **INITRANS**

    初始化数据块中事务槽的个数。

-   _**storage\_clause**_
    -   **INITIAL  _integer _\[K | M | G | T\]**

        单个分区的初始大小，可通过INITIAL来指定单个分区的初始大小。取值范围是\[64K, 1T\]。

        分区表指定初始大小时只对没有指定STORAGE INITIAL的分区起作用。

    -   **MAXSIZE \{ UNLIMITED |  _integer _\[K | M | G | T\] \}**

        单个分区存储空间的最大值。分区表指定最大值时只对没有指定STORAGE MAXSIZE的分区起作用。

        -   **UNLIMITED**

            表示不限制单个分区存储空间的最大值。

        -   **_integer _\[K | M | G | T\]**

            设置单个的存储空间最大值，取值范围是\[1M, 1T\]。

-   **_table\_properties_**

    指定表属性。

-   **AUTO\_INCREMENT \[ = \]  _value_**

    建表时可用“AUTO\_INCREMENT=n”选项来指定一个自增的初始值。不指定从1开始，指定从value开始。

-   **APPENDONLY \{ ON | OFF \}**

    -   APPENDONLY ON表示不同的线程在对同一张表插入时，会申请新的page做插入，而不会去使用未插满的page。这种情况下，页面锁等待时长减少，但 page空间浪费较多。
        -   对于分区表，当把APPENDONLY设置为ON时，并行插入场景会有问 题，需要用户提前组织好每个并行线程所插入的数据，确保每个线程内插入的时候不会切换分区，即一个线程对应一个分区。
        -   HASH分区表的不建议设置APPENDONLY为ON。

    -   APPENDONLY OFF表示不同的线程在对同一张表插入时，会尽量插满page空间。这种情况下，等锁时间比较长。

    不指定时，默认为OFF。

    使用APPENDONLY 时需谨慎操作，使用不当将造成大量空间浪费。

-   **LOB\_storage\_clause**
    -   **LOB \( LOB\_item \) STORE AS \{ \[ \( LOB\_parameters \) \]**

        指定lob字段单独segment储存，可以指定线行内存储和行外存储。目前存储层只支持行外存储。

    -   **LOB\_item**

        lob字段名称。

    -   **LOB\_parameters**

        lob字段存储参数。

        **\{ENABLE | DISABLE \} STORAGE IN ROW**

        行内存储和行外存储。

        -   **ENABLE**

            行内存储。

        -   **DISABLE**

            行外存储。

-   _**range\_partitioning**_

    范围分区。

-   _**partition\_key**_

    分区键所在列的集合。分区键所在列中，单列的长度不能超过2000。

    分区键支持如下数据类型：

    int、integer、bigint、number、decimal、real、double、numeric、varchar、 varchar2、char、binary、raw、date、datetime、timestamp。

-   **PARTITION**

    分区表。

-   **SUBPARTITION**

    子分区表。

-   **_partition\_name_**

    范围分区的名称。

-   **_subpartition\_name_**

    子分区的名字。

-   **VALUES LESS THAN**

    范围分区的上边界关键字。

-   _**partition\_value**_

    范围分区的上边界。

    每个分区都需要指定一个上边界。

    分区上边界的类型应当和分区键的类型一致。

    分区列表是按照分区上边界升序排列的，值较小的分区位于值较大的分区之前。

-   **MAXVALUE**

    一个关键字。

    在创建范围分区时可以使用。MAXVALUE表示分区的上边界，它通常用于设置最后一个范围分区的上边界。

    对于间隔分区策略，是不允许范围分区的上边界为MAXVALUE。

-   **_list\_partitioning_**

    LIST分区，按照分区键值相同分区，单个分区的list个数不能超过500。

    **DEFAULT**

    指定default分区，如果插入的数据是default值，就会分配到default分区。

-   **hash\_partitioning**

    创建HASH分区。创建时指定列，在该列上创建HASH分区。

    **STORE IN**

    hash分区存储的指定的表空间，子分区类型如果为HASH类型，也支持STORE IN 关键字，语法与一级分区一样。

-   **interval\_partitioning**

    创建间隔分区。

**示例<a name="section798141011563"></a>**

-   创建分区表employment\_history，按照哈希分区。

    ```
    --删除表employment_history。
    DROP TABLE IF EXISTS employment_history;
    ```

    ```
    --创建分区表employment_history，按照哈希分区。
    create table employment_history
    (
      staff_id   NUMBER(6), 
      start_date   DATE, 
      end_date     DATE,
      employment_id       VARCHAR2(10), 
      section_id NUMBER(4)
    ) PARTITION BY HASH(start_date) PARTITIONS 2;
    ```

-   创建分区表education，按照列表分区。

    ```
    --删除表education。
    DROP TABLE IF EXISTS education;
    ```

    ```
    --创建分区表education，按照列表分区。
    CREATE TABLE education(staff_id INT NOT NULL, highest_degree CHAR(8), graduate_school VARCHAR(64), graduate_date DATETIME, education_note VARCHAR(70)) PARTITION BY LIST(highest_degree)
    (
    PARTITION doctor VALUES ('DOCTOR'), 
    PARTITION master VALUES ('MASTER'),
    PARTITION undergraduate VALUES ('SCHOLAR')
    );
    ```

-   创建分区表training，按照范围分区。

    ```
    --删除表training。
    DROP TABLE IF EXISTS training;
    ```

    ```
    --创建分区表training，按照范围分区。
    CREATE TABLE training(staff_id INT NOT NULL, course_name CHAR(20), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT) PARTITION BY RANGE(staff_id)
    (
    PARTITION training1 VALUES LESS than(100), 
    PARTITION training2 VALUES LESS than(200), 
    PARTITION training3 VALUES LESS than(300), 
    PARTITION training4 VALUES LESS than(MAXVALUE)
    );
    ```

-   创建分区表training\_interval，按照间隔分区。

    ```
    --删除表training_interval。
    DROP TABLE IF EXISTS training_interval;
    ```

    ```
    --创建表training_interval。
    CREATE TABLE training_interval(staff_id INT NOT NULL, course_name CHAR(20), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT) 
    PARTITION BY RANGE(staff_id) INTERVAL (100)
    (
    PARTITION training1 VALUES LESS than(100), 
    PARTITION training2 VALUES LESS than(200)
    );
    ```

-   创建分区表TEST\_STORAGE，按照范围分区。设置PART1 分区的INITIAL值是2M，MAXSIZE 是3M，PART2分区的INITIAL值是1M，MAXSIZE 是2M。

    ```
    --删除表。
    DROP TABLE IF EXISTS TEST_STORAGE;
    ```

    ```
    --创建表。
    CREATE TABLE TEST_STORAGE(PART_ID INT, C_CHAR1 VARCHAR2(4000)) 
    STORAGE (MAXSIZE 2M INITIAL 1M) 
    PARTITION BY RANGE (PART_ID) (
    PARTITION PART1 VALUES LESS THAN (2) STORAGE (MAXSIZE 3M INITIAL 2M), 
    PARTITION PART2 VALUES LESS THAN (3)
    );
    ```

## CREATE USER<a name="ZH-CN_TOPIC_0000001788626092"></a>

**功能描述<a name="section1858811101760"></a>**

创建一个数据库用户。

**注意事项<a name="section196182261468"></a>**

-   执行该语句的用户需要有CREATE USER系统权限。
-   允许的最大用户上限值是15000，超过上限会报错。
-   单个用户可接受对象权限的对象个数为2048\*2048。
-   用户名不能和数据库中已存在的用户名和角色名重复，否则会提示错误：user \*name\* already exists。
-   创建用户时，需要指定用户名和密码，首次登录需要修改密码，修改方法参见[ALTER USER](ALTER-USER.md)。
-   ctctsql客户端新建用户时，出于安全考虑可以在创建同时手动设置密码过期（设置方法请参见[PASSWORD EXPIRE](#li7917154311150)），或者通过[ALTER USER](ALTER-USER.md)语句设置用户密码过期，后续用户通过ctctsql客户端交互式修改用户密码登录，确保密码可知的范围。
-   SYS用户和PUBLIC用户不允许创建，是系统预置用户。
    -   SYS用户用于初始创建数据库实例。
    -   PUBLIC是系统预置的公共用户，它表示所有数据库用户的集合。如果PUBLIC用户被授予某个权限，则数据库的所有用户都拥有这个权限。例如：
        -   将对象t1的SELECT权限授予PUBLIC用户，则所有用户均可以访问表t1。

            ```
            GRANT SELECT ON user1.t1 TO PUBLIC;
            ```

        -   授予PUBLIC用户DBA权限，则所有用户均用于DBA权限。

            ```
            GRANT DBA TO PUBLIC;
            ```

-   在新建的租户中创建第一个用户必须使用根租户下的用户登录并切换tenant到目标租户然后创建用户。
-   允许在不同租户中创建同名的用户。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >根租户中的公共用户存储在系统表SYS\_USERS中的名字无变化。非根租户中的本地用户存储在系统表SYS\_USERS中的名字是tenant\_name$user\_name。因此对于非根租户中的本地用户来说，名字最大长度与其所属的租户的名字长度有关，tenant\_name$user\_name的最大长度为64。

**语法格式<a name="section179391171691"></a>**

```
CREATE USER user_name
    IDENTIFIED BY password
    [  ENCRYPTED
     | DEFAULT TABLESPACE tablespace_name
     | TEMPORARY TABLESPACE tablespace_name
     | PASSWORD EXPIRE
     | ACCOUNT { LOCK | UNLOCK }
     | PROFILE profile_name
     | PERMANENT
  ] [ ... ]
```

**参数说明<a name="section13472111115112"></a>**

-   **_user\_name_**

    用户名。

    -   用户名不允许包含以下特殊字符：分号（;）、竖线（|）、反引号（\`）、美元符（$）、位运算（ &）、大于号（\>）、小于号（<）、双引号（"）、单引号（'）、感叹号（！）、空格和版权符号（©），即使用双引号或者反引号括起来也不行。
    -   若用户名包含以上禁止特殊字符以外的其他特殊字符时，必须用双引号（""）或者反引号（\`\`）括起来。
    -   用户名默认转成大写，双引号内前面的空格和tab键都会删除，实际不带空格。
    -   由于SYSDBA、CLSMGR为数据库关键字，这些名称的用户会登录不上数据库，建议用户不要创建该名称的用户。

-   **IDENTIFIED BY**

    创建用户时，给用户指定密码。

-   _**password**_

    用户密码。

    设置用户密码时，需要遵循如下规范：

    -   密码长度必须大于等于8个字符（如果是主备之间认证的密码，密码长度必须大于等于16个字符），小于等于64个字符。
    -   若密码不以单引号括起来，则密码首字符必须是字母、\#号或下划线。
    -   密码不能与用户名或者用户名的倒序相同（校验时，不区分大小写）。
    -   密码只能包含以下4种类型，并且至少选取其中3种类型的组合。
        -   数字。
        -   小写字母。
        -   大写字母。
        -   空格或特殊字符（Cantian引擎支持的特殊字符列表，请参见[表1](#table6964mcpsimp)。

    -   创建密码时，若密码中包含\_\#$以外的特殊字符或者空格，则密码须用单引号括起来。
    -   若创建的密码中包含特殊字符$，通过ctsql连接数据库时密码在单引号里面$不需要使用\\转义字符转义，密码不在单引号里面$需要使用\\转义字符转义，否则会登录失败。
    -   若创建的密码中包含特殊字符空格，只能通过交互式登录。
    -   使用conn命令登录数据库密码段都认为是密码字符。
    -   使用ctsql命令登录数据库密码字段使用单引号括起来。密码中不能出现单引号。

-   **DEFAULT TABLESPACE  _tablespace\_name_**

    定义用户私有默认表空间。表空间必须存在。

-   **TEMPORARY TABLESPACE  _tablespace\_name_**

    定义用户默认临时表空间。表空间必须存在。目前仅支持指定临时表空间为temp表空间。

-   <a name="li7917154311150"></a>**PASSWORD EXPIRE**

    密码过期，过期后该用户登入提示“the password has expired”。

    当客户端是ctsql时，密码过期的账户在登录时会出现修改密码的交互式窗口，强制修改该用户密码。

    -   密码修改成功，进入连接。
    -   密码修改失败，退出交互式窗口。
    -   其余类型客户端，直接报错退出。

-   **ACCOUNT \{ LOCK | UNLOCK \}**

    手动锁定用户，锁定后该用户登入提示“the account is locked”，禁止登入。

-   **_profile\_name_**

    档案名。

    用户引用一个profile，profile必须提前创建并配置。当创建用户时没有明确指定PROFILE，默认引用default PROFILE。

    >![](public_sys-resources/icon-notice.gif) **须知：** 
    >默认系统管理员SYS用户默认引用归档文件default PROFILE，普通用户为了避免设置用户安全策略时影响到SYS用户，建议给用户创建自己的PROFILE。

-   **ENCRYPTED**

    用于标识指定的密码是加密的密文，建议使用单引号进行标识，当指定为密文时不校验密码规范。密文由工具ctencrypt加密生成。

    若指定ENCRYPTED关键字，则必须位于_password _后的第一个参数位置，否则会报错。

    使用ENCRYPTED方式创建的用户需要用明文密码登录，不推荐采用此方式创建用户。

-   **PERMANENT**

    不可删除的用户的标志。此类账户只可以由SYS用户进行创建和删除。

    账户创建后，执行变更密码、切换锁定状态、手动密码过期、变更指定的档案、变更用户表空间操作时，只能由SYS用户进行。

    此类账户其他特性同普通账户，例如：如果修改此类账户的profile文件，其对账户的影响等同于普通账户。

**表 1**  特殊字符

<a name="table6964mcpsimp"></a>
<table><tbody><tr id="row6975mcpsimp"><td class="cellrowborder" valign="top" width="10%"><p id="p6977mcpsimp"><a name="p6977mcpsimp"></a><a name="p6977mcpsimp"></a><strong id="b6978mcpsimp"><a name="b6978mcpsimp"></a><a name="b6978mcpsimp"></a>编号</strong></p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p6980mcpsimp"><a name="p6980mcpsimp"></a><a name="p6980mcpsimp"></a><strong id="b6981mcpsimp"><a name="b6981mcpsimp"></a><a name="b6981mcpsimp"></a>字符</strong></p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p6983mcpsimp"><a name="p6983mcpsimp"></a><a name="p6983mcpsimp"></a><strong id="b6984mcpsimp"><a name="b6984mcpsimp"></a><a name="b6984mcpsimp"></a>编号</strong></p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p6986mcpsimp"><a name="p6986mcpsimp"></a><a name="p6986mcpsimp"></a><strong id="b6987mcpsimp"><a name="b6987mcpsimp"></a><a name="b6987mcpsimp"></a>字符</strong></p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p6989mcpsimp"><a name="p6989mcpsimp"></a><a name="p6989mcpsimp"></a><strong id="b6990mcpsimp"><a name="b6990mcpsimp"></a><a name="b6990mcpsimp"></a>编号</strong></p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p6992mcpsimp"><a name="p6992mcpsimp"></a><a name="p6992mcpsimp"></a><strong id="b6993mcpsimp"><a name="b6993mcpsimp"></a><a name="b6993mcpsimp"></a>字符</strong></p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p6995mcpsimp"><a name="p6995mcpsimp"></a><a name="p6995mcpsimp"></a><strong id="b6996mcpsimp"><a name="b6996mcpsimp"></a><a name="b6996mcpsimp"></a>编号</strong></p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p6998mcpsimp"><a name="p6998mcpsimp"></a><a name="p6998mcpsimp"></a><strong id="b6999mcpsimp"><a name="b6999mcpsimp"></a><a name="b6999mcpsimp"></a>字符</strong></p>
</td>
</tr>
<tr id="row7000mcpsimp"><td class="cellrowborder" valign="top" width="10%"><p id="p7002mcpsimp"><a name="p7002mcpsimp"></a><a name="p7002mcpsimp"></a>1</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p7004mcpsimp"><a name="p7004mcpsimp"></a><a name="p7004mcpsimp"></a>`</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7006mcpsimp"><a name="p7006mcpsimp"></a><a name="p7006mcpsimp"></a>9</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7008mcpsimp"><a name="p7008mcpsimp"></a><a name="p7008mcpsimp"></a>&amp;</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p7010mcpsimp"><a name="p7010mcpsimp"></a><a name="p7010mcpsimp"></a>17</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7012mcpsimp"><a name="p7012mcpsimp"></a><a name="p7012mcpsimp"></a>\</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p7014mcpsimp"><a name="p7014mcpsimp"></a><a name="p7014mcpsimp"></a>25</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7016mcpsimp"><a name="p7016mcpsimp"></a><a name="p7016mcpsimp"></a>"</p>
</td>
</tr>
<tr id="row7017mcpsimp"><td class="cellrowborder" valign="top" width="10%"><p id="p7019mcpsimp"><a name="p7019mcpsimp"></a><a name="p7019mcpsimp"></a>2</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p7021mcpsimp"><a name="p7021mcpsimp"></a><a name="p7021mcpsimp"></a>~</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7023mcpsimp"><a name="p7023mcpsimp"></a><a name="p7023mcpsimp"></a>10</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7025mcpsimp"><a name="p7025mcpsimp"></a><a name="p7025mcpsimp"></a>*</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p7027mcpsimp"><a name="p7027mcpsimp"></a><a name="p7027mcpsimp"></a>18</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7029mcpsimp"><a name="p7029mcpsimp"></a><a name="p7029mcpsimp"></a>|</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p7031mcpsimp"><a name="p7031mcpsimp"></a><a name="p7031mcpsimp"></a>26</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7033mcpsimp"><a name="p7033mcpsimp"></a><a name="p7033mcpsimp"></a>,</p>
</td>
</tr>
<tr id="row7034mcpsimp"><td class="cellrowborder" valign="top" width="10%"><p id="p7036mcpsimp"><a name="p7036mcpsimp"></a><a name="p7036mcpsimp"></a>3</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p7038mcpsimp"><a name="p7038mcpsimp"></a><a name="p7038mcpsimp"></a>!</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7040mcpsimp"><a name="p7040mcpsimp"></a><a name="p7040mcpsimp"></a>11</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7042mcpsimp"><a name="p7042mcpsimp"></a><a name="p7042mcpsimp"></a>(</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p7044mcpsimp"><a name="p7044mcpsimp"></a><a name="p7044mcpsimp"></a>19</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7046mcpsimp"><a name="p7046mcpsimp"></a><a name="p7046mcpsimp"></a>[</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p7048mcpsimp"><a name="p7048mcpsimp"></a><a name="p7048mcpsimp"></a>27</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7050mcpsimp"><a name="p7050mcpsimp"></a><a name="p7050mcpsimp"></a>&lt;</p>
</td>
</tr>
<tr id="row7051mcpsimp"><td class="cellrowborder" valign="top" width="10%"><p id="p7053mcpsimp"><a name="p7053mcpsimp"></a><a name="p7053mcpsimp"></a>4</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p7055mcpsimp"><a name="p7055mcpsimp"></a><a name="p7055mcpsimp"></a>@</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7057mcpsimp"><a name="p7057mcpsimp"></a><a name="p7057mcpsimp"></a>12</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7059mcpsimp"><a name="p7059mcpsimp"></a><a name="p7059mcpsimp"></a>)</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p7061mcpsimp"><a name="p7061mcpsimp"></a><a name="p7061mcpsimp"></a>20</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p7063mcpsimp"><a name="p7063mcpsimp"></a><a name="p7063mcpsimp"></a>{</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p7065mcpsimp"><a name="p7065mcpsimp"></a><a name="p7065mcpsimp"></a>28</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p7067mcpsimp"><a name="p7067mcpsimp"></a><a name="p7067mcpsimp"></a>.</p>
</td>
</tr>
<tr id="row05726541173"><td class="cellrowborder" valign="top" width="10%"><p id="p12175186151816"><a name="p12175186151816"></a><a name="p12175186151816"></a>5</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p2017536141816"><a name="p2017536141816"></a><a name="p2017536141816"></a>#</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p1417514641811"><a name="p1417514641811"></a><a name="p1417514641811"></a>13</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p1175206121817"><a name="p1175206121817"></a><a name="p1175206121817"></a>-</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p517518615183"><a name="p517518615183"></a><a name="p517518615183"></a>21</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p11175106101818"><a name="p11175106101818"></a><a name="p11175106101818"></a>}</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p14175767182"><a name="p14175767182"></a><a name="p14175767182"></a>29</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p1217586191815"><a name="p1217586191815"></a><a name="p1217586191815"></a>&gt;</p>
</td>
</tr>
<tr id="row1433316514187"><td class="cellrowborder" valign="top" width="10%"><p id="p1417696101811"><a name="p1417696101811"></a><a name="p1417696101811"></a>6</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p01760614185"><a name="p01760614185"></a><a name="p01760614185"></a>$</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p11761665187"><a name="p11761665187"></a><a name="p11761665187"></a>14</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p151761065183"><a name="p151761065183"></a><a name="p151761065183"></a>_</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p191768617188"><a name="p191768617188"></a><a name="p191768617188"></a>22</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p11761667185"><a name="p11761667185"></a><a name="p11761667185"></a>]</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p2176156201810"><a name="p2176156201810"></a><a name="p2176156201810"></a>30</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p1417618681813"><a name="p1417618681813"></a><a name="p1417618681813"></a>/</p>
</td>
</tr>
<tr id="row1752413161820"><td class="cellrowborder" valign="top" width="10%"><p id="p161766631813"><a name="p161766631813"></a><a name="p161766631813"></a>7</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p3176176131815"><a name="p3176176131815"></a><a name="p3176176131815"></a>%</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p171761266182"><a name="p171761266182"></a><a name="p171761266182"></a>15</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p5176146191811"><a name="p5176146191811"></a><a name="p5176146191811"></a>=</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p5176762188"><a name="p5176762188"></a><a name="p5176762188"></a>23</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p1417614618183"><a name="p1417614618183"></a><a name="p1417614618183"></a>:</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p617656181812"><a name="p617656181812"></a><a name="p617656181812"></a>31</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p71765631812"><a name="p71765631812"></a><a name="p71765631812"></a>?</p>
</td>
</tr>
<tr id="row771716141816"><td class="cellrowborder" valign="top" width="10%"><p id="p191762671818"><a name="p191762671818"></a><a name="p191762671818"></a>8</p>
</td>
<td class="cellrowborder" valign="top" width="11%"><p id="p1117616651816"><a name="p1117616651816"></a><a name="p1117616651816"></a>^</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p1217696121811"><a name="p1217696121811"></a><a name="p1217696121811"></a>16</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p317611612182"><a name="p317611612182"></a><a name="p317611612182"></a>+</p>
</td>
<td class="cellrowborder" valign="top" width="14.000000000000002%"><p id="p6176560182"><a name="p6176560182"></a><a name="p6176560182"></a>24</p>
</td>
<td class="cellrowborder" valign="top" width="12%"><p id="p31779618186"><a name="p31779618186"></a><a name="p31779618186"></a>'</p>
</td>
<td class="cellrowborder" valign="top" width="15%"><p id="p517796131814"><a name="p517796131814"></a><a name="p517796131814"></a>-</p>
</td>
<td class="cellrowborder" valign="top" width="13%"><p id="p1217714691810"><a name="p1217714691810"></a><a name="p1217714691810"></a>-</p>
</td>
</tr>
</tbody>
</table>

**示例<a name="section115042141811"></a>**

创建用户jessica，设置手动密码过期后给用户返回登入提示。

```
CREATE USER jessica IDENTIFIED BY 'Test@123' PASSWORD EXPIRE;
```

## CREATE VIEW<a name="ZH-CN_TOPIC_0000001788466484"></a>

**功能描述<a name="section2067911417214"></a>**

创建一个视图。

视图与基本表不同，是一个虚表。数据库中仅存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。若基本表中的数据发生变化，从视图中查询出的数据也随之改变。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中用户感兴趣的数据及变化。

**注意事项<a name="section1077491918214"></a>**

执行该语句的用户需要有CREATE VIEW、CREATE ANY VIEW系统权限，普通用户不可以创建系统用户对象。

**语法格式<a name="section17813936162118"></a>**

```
CREATE [ OR REPLACE [ FORCE ] ] VIEW [ schema_name. ]view_name [ ( alias [ ,... ] ) ] AS subquery	
```

**参数说明<a name="section20181154132111"></a>**

-   **\[OR REPLACE \[ FORCE \]\]**

    -   **OR REPLACE： **创建视图时，若视图存在则更新。
    -   **OR REPLACE FORCE **：即使subquery校验失败也会强制创建成功，

        subquery校验失败强制创建成功后视图状态为INVALID。

    注意：当前**OR REPLACE FORCE**不支持subquery为select \* 语法，必须指定视图列名。

-   **\[schema\_name.\]  _view\_name_**

    视图名。

-   **\[\(  _alias _\[ ,... \]\)\]**

    视图列别名，若不给出，将根据后面子查询自动推导列名。

-   **AS  _subquery_**

    子查询。

**示例<a name="section13668155310223"></a>**

创建视图privilege\_view，若该视图存在则更新该视图。

```
--删除表privilege。
DROP TABLE IF EXISTS privilege;
```

```
--创建表privilege。
CREATE TABLE privilege(staff_id INT PRIMARY KEY, privilege_name VARCHAR(64) NOT NULL, privilege_description VARCHAR(64), privilege_approver VARCHAR(10));
```

```
--创建视图privilege_view，若该视图存在则更新该视图。
CREATE OR REPLACE VIEW privilege_view AS SELECT staff_id, privilege_name from privilege;
```

创建视图privilege\_view并指定视图列别名，若该视图存在则更新该视图。

```
CREATE OR REPLACE VIEW privilege_view(staff, privilege, description, approver) AS SELECT * FROM privilege;
```

## DROP INDEX<a name="ZH-CN_TOPIC_0000001788466408"></a>

**功能描述<a name="section11218345568"></a>**

删除索引。

**注意事项<a name="section14661104245618"></a>**

-   如果删除当前用户的索引，不需要授予额外权限。
-   如果要删除其他用户的索引，当前用户需要被授予DROP ANY INDEX系统权限，普通用户不可以删除系统用户对象。
-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section11524519577"></a>**

-   删除普通表和全局临时表的索引。

    ```
    DROP INDEX [ IF EXISTS ] [ schema_name. ]index_name [ ON [schema_name.]table_name ]
    ```

-   删除本地临时表的索引。

    ```
    DROP INDEX [ IF EXISTS ] [ schema_name. ]index_name { ON [schema_name.]table_name }
    ```

**参数说明<a name="section092952125717"></a>**

-   **IF EXISTS**

    索引不存在时，直接返回成功。

-   **\[_schema\_name._\]_ index\_name_**

    待删除索引名。

-   **ON \[  _schema\_name_. \]  _table\_name_**

    删除索引时指定表名。

**示例<a name="section712512321019"></a>**

删除索引。

```
DROP INDEX IF EXISTS idx_training ON table_name;
```

## DROP TABLE<a name="ZH-CN_TOPIC_0000001835225669"></a>

**功能描述<a name="section1820420588911"></a>**

删除表。

**注意事项<a name="section1459413516108"></a>**

-   用户能删除自己的表；删除其他用户下的表，需要DROP ANY TABLE权限，普通用户不可以删除系统用户对象。
-   开启回收站功能时，删除表并不会立即把表中记录删除，而是将表重命名置recycle标记，并放入回收站。此时还可以通过flashback命令回退。

    system表空间下的表不支持放入回收站，会直接删除，无法通过flashback命令回退。

    当前Cantian引擎默认开启回收站功能，如果回收站未开启，可通过ALTER SYSTEM SET RECYCLEBIN = TRUE;命令开启。

-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section472311117102"></a>**

```
DROP [TEMPORARY] TABLE [ IF EXISTS ] [ schema_name. ]table_name [CASCADE CONSTRAINTS][ PURGE ]
```

**参数说明<a name="section565151712105"></a>**

-   **TEMPORARY**

    删除临时表，后面的表名只能是临时表。

-   **IF EXISTS**

    表不存在时，返回成功。

-   **\[_schema\_name_.\]_table\_name_**

    待删除表名。

-   **CASCADE CONSTRAINTS**

    如果被删除的父表被别的子表的外键引用，那么删除父表会报错，在这种情况下，使用CASCADE CONSTRAINTS则可以删除父表，并且把引用该父表的外键也删除。

**示例<a name="section26517456107"></a>**

-   删除表privilege。

    ```
    DROP TABLE IF EXISTS privilege;
    ```

-   直接删除临时表privilege。

    ```
    DROP TEMPORARY TABLE IF EXISTS privilege;
    ```

## DROP TABLESPACE<a name="ZH-CN_TOPIC_0000001788466480"></a>

**功能描述<a name="section1820420588911"></a>**

删除表空间。

**注意事项<a name="section1459413516108"></a>**

-   执行该语句的用户需要有DROP TABLESPACE系统权限。
-   offline的表空间必须在数据库open模式删除。
-   不能删除system、undo、临时表空间。
-   MOUNT模式下不能删除表空间。
-   带SHARD关键字仅支持分布式场景，单机不生效。

**语法格式<a name="section472311117102"></a>**

```
DROP TABLESPACE tablespace_name  [ INCLUDING CONTENTS [ { AND | KEEP }  DATAFILES ] ][SHARD]
```

**参数说明<a name="section565151712105"></a>**

-   _**tablespace\_name**_

    表空间名。

-   **INCLUDING CONTENTS \{AND | KEEP\}  DATAFILES**

    删除表空间时同时删除或保持数据文件。

    -   **AND**

        删除表空间时同时删除数据文件。

    -   **KEEP**

        删除表空间时保持数据文件。

-   **DATAFILES**

    数据文件名称。

-   **SHARD**

    命令支持下发到所有的CN和DN节点。若不指定，则需在所有的CN和DN节点手动执行该命令。该关键字仅支持分布式场景，单机不生效。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >-   不指定including选项时，如果要删除的表空间中还存在表、索引、lob等对象或者该表空间为用户默认表空间，则会返回错误。
    >-   如果指定including选项，会同时删除该表空间下的对象，但该表空间为用户默认表空间或者表空间下的对象与其他表空间的对象有关联关系时，会返回错误。例如，存在其他表空间的外键、分区表的部分分区指定为该表空间、其他表空间表的索引在该表空间等。

**示例<a name="section26517456107"></a>**

-   OPEN状态下删除表空间，并同时删除数据文件。

    ```
    --OPEN状态下创建表空间human_space3。 
    CREATE TABLESPACE human_space3 DATAFILE '-human_dfile3' SIZE 32M AUTOEXTEND ON NEXT 10M;
    ```

    ```
    --OPEN状态下删除表空间human_space3，同时删除数据文件。 
    DROP TABLESPACE human_space3 INCLUDING CONTENTS AND DATAFILES;
    ```

-   OPEN状态下删除表空间，并同时保留数据文件。

    ```
    --OPEN状态下创建表空间human_space4。 
    CREATE TABLESPACE human_space4 DATAFILE '-human_dfile4' SIZE 32M;
    ```

    ```
    --OPEN状态下删除表空间human_space4，同时保留数据文件。
    DROP TABLESPACE human_space4 INCLUDING CONTENTS KEEP DATAFILES;
    ```

## DROP USER<a name="ZH-CN_TOPIC_0000001788626064"></a>

**功能描述<a name="section665992112123"></a>**

删除一个已经存在的数据库用户。

**注意事项<a name="section1461073771210"></a>**

-   执行该语句的用户需要有DROP USER系统权限。
-   如果指定的用户不存在，且没有指定 if exists 选项，会提示错误信息：user  _name _does not exist。
-   数据库重启回滚期间不支持该操作。
-   单用户名下对象不超过5万个，建议先删除该用户创建的数据表对象，再删除用户。
-   请谨慎使用该操作，即使删除过程中断，已经删除的对象也无法恢复。

**语法格式<a name="section03941312111314"></a>**

```
DROP USER [ IF EXISTS ] user_name [ CASCADE ]
```

**参数说明<a name="section1317143211158"></a>**

-   _**user\_name**_

    要删除的用户名。

-   **IF EXISTS**

    要删除的用户是否存在。如果指定的用户不存在，直接返回执行成功，存在则删除该用户。

-   **CASCADE**
    -   不指定CASCADE选项时，如果要删除的用户中还有数据库对象没有删除，会提示错误信息：

        ```
        CT-00815, user objects is being used, can not drop
        ```

-   如果指定CASCADE选项，删除该用户时，会同步强制删除属于该用户的数据库对象，包括：表、表上创建的索引、表上创建的约束（包括引用该表的外键约束）和触发器、序列、视图（不包括视图中引用的其他用户的对象）、函数/存储过程、回收站中属于该用户的表。

**示例<a name="section18432568207"></a>**

删除用户zwx003，同时强制删除属于该用户的数据库对象。

```
--创建用户zwx003，密码是Test@123。
CREATE USER zwx003 IDENTIFIED BY 'Test@123';
```

```
--删除用户zwx003，同时强制删除属于该用户的数据库对象。 
DROP USER zwx003 CASCADE;
```

## DROP VIEW<a name="ZH-CN_TOPIC_0000001835265565"></a>

**功能描述<a name="section13996145572111"></a>**

删除视图。

**注意事项<a name="section16801510223"></a>**

-   用户能删除自己的视图，删除其他用户的视图，需要DROP ANY VIEW权限，普通用户不可以删除系统用户对象。
-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section514516177225"></a>**

```
DROP VIEW [ IF EXISTS ] [ schema_name. ]view_name
```

**参数说明<a name="section158401931132218"></a>**

-   **IF EXISTS**

    视图存在，则执行删除。

-   **_\[schema\_name.\] view\_name_**

    待删除的视图。

**示例<a name="section53611561220"></a>**

删除视图privilege\_view。

```
--删除表privilege。
DROP TABLE IF EXISTS privilege;
```

```
--创建表privilege。
CREATE TABLE privilege(staff_id INT PRIMARY KEY, privilege_name VARCHAR(64) NOT NULL, privilege_description VARCHAR(64), privilege_approver VARCHAR(10));
```

```
--创建视图privilege_view。
CREATE OR REPLACE VIEW privilege_view AS SELECT staff_id, privilege_name from privilege;
```

```
--删除视图privilege_view。
DROP VIEW IF EXISTS privilige_view;
```

## INSERT<a name="ZH-CN_TOPIC_0000001788466472"></a>

**功能描述<a name="section1887158526"></a>**

在表中插入新的数据。

INSERT语句有三种形式：

-   第一种是值插入，即构造一行记录并插入到表中。
-   第二种形式是查询插入，它通过SELECT子句返回的结果集构造一行或多行记录插入到表中。
-   第三种是先插入记录，如果报主键冲突错误则执行UPDATE操作，更新指定字段值。

**注意事项<a name="section1794831810525"></a>**

-   如果当前操作用户不是表的属主，则执行时需要有表的INSERT对象权限或者INSERT ANY TABLE的系统权限。普通用户不允许insert系统SYS用户对象。
-   INSERT事务提交是默认关闭的。会话退出时，需要显式COMMIT，否则记录将丢失。
-   INSERT ...SELECT形式，select\_list列数必须与待插入的字段数一样。
-   INSERT中单行数据量需小于64000字节。

**语法格式<a name="section9996732155216"></a>**

-   值插入。

    ```
    INSERT [hint_info] [IGNORE] [ INTO ] [ schema_name. ]table_name [ ( column_name [ , ... ] ) ] VALUES ( expression [ , ... ] )
    ```

-   查询插入。

    ```
    INSERT [hint_info] [IGNORE] [ INTO ] [ schema_name. ]table_name [table_alias][ ( column_name [ , ... ] ) ]select_clause [ON DUPLICATE KEY UPDATE {column_name = expression} [ , ... ]]
    ```

    -   _select\_clause_

        ```
        SELECT [ DISTINCT ] select_list FROM table_list [ where_clause ] [ group_by_clause ] [ order_by_clause ] [ limit_clause ]
        ```

-   主键冲突错误，执行UPDATE操作。

    ```
    INSERT [ INTO ] [ schema_name. ]table_name [ ( column_name [ , ... ] ) ]  VALUES ( expression [ , ... ] ) ON DUPLICATE KEY UPDATE {column_name = expression} [ , ... ]
    ```

**参数说明<a name="section12709192265515"></a>**

-   **hint\_info**
    -   – hint\_info是SQL语句中的特殊注释，用于将指令传递给数据库优化器。优化器使用这些提示为SQL语句选择执行计划，除非存在阻止优化器这样做的某些条件。
    -   请谨慎使用hint\_info。建议在收集了相关表的统计信息，并且通过EXPLAIN PLAN评估过不带hint\_info的优化器执行计划后，使用hint\_info。
    -   在后续版本中的数据库条件变化及查询性能增强，都会对hint\_info所起的作用产生影响。如果决定使用提示，需要注意任何使用提示所产生的短期利益不一定会产生长期改善。
    -   parallel hint目前只支持单表全表扫描，支持聚集函数并行、order by并行、 group by并行、build hash table并行、单表扫描返回大量结果集并行。

-   **IGNORE**

    用于忽略会导致重复关键字错误的记录，不支持和ON DUPLICATE KEY UPDATE同时使用。

-   **_table\_name_**

    待插入的表名。

-   **_table\_alias_**

    待插入的表的别名。

-   **_column\_name_**

    待插入的表字段名。

    如果insert语句所指定的字段名包含表中的所有字段，则可能省略字段名。取值范围：已存在的字段名。

-   **_expression_**

    插入字段的值或表达式。

-   **_select\_clause_**

    SELECT查询结果集作为新值插入到表中，具体参数，参考[SELECT](SELECT.md)章节。

-   **_select\_list_**

    指定查询列。

-   **_table\_list_**

    指定查询表，可以是表、视图、子查询。

-   **DISTINCT**

    关键字，表示查询结果集是否需要去重。

    取值范围：已存在的字段名，或字段表达式。

-   **_where\_clause_**

    指定查询结果集要满足的条件。

-   **_group\_by\_clause_**

    指定查询结果集要满足的分组规则。

-   **_order\_by\_clause_**

    指定查询结果集要满足的排序规则。

-   **_limit\_clause_**

    指定查询结果集要满足的界限。

-   **ON DUPLICATE KEY UPDATE**

    指定插入记录的主键或UNIQUE索引和已有记录的主键或UNIQUE索引冲突时执行 UPDATE操作。根据索引定义的顺序遍历各列查找冲突记录。例如，表t1包含三 列，列名分别为f1、f2、f3，索引建立顺序为f3-\>f2-\>f1，那么在插入记录的主键或UNIQUE索引和已有记录的主键或UNIQUE索引冲突时，Cantian引擎通过遍历列数据查找冲突的顺序为f3-\>f2-\>f1。

**示例<a name="section783415411574"></a>**

向表trainning中插入数据。

```
--删除表training。
DROP TABLE IF EXISTS training;
```

```
--创建表training。
CREATE TABLE training(staff_id INT NOT NULL PRIMARY KEY,course_name CHAR(50),course_start_date
DATETIME, course_end_date DATETIME,exam_date DATETIME,score INT);
```

```
--向表training中插入记录1。
INSERT INTO training(staff_id,course_name,course_start_date,course_end_date,exam_date,score)
VALUES(10,'SQL majorization','2017-06-15 12:00:00','2017-06-20 12:00:00','2017-06-25 12:00:00',90);
--向表training中插入记录2。
INSERT INTO training(staff_id,course_name,course_start_date,course_end_date,exam_date,score)
VALUES(11,'information safety','2017-06-20 12:00:00','2017-06-25 12:00:00','2017-06-26 12:00:00',95);
--向表training中插入记录3。
INSERT INTO training(staff_id,course_name,course_start_date,course_end_date,exam_date,score)
VALUES(12,'master all kinds of thinking methonds','2017-07-15 12:00:00','2017-07-20 12:00:00','2017-07-25 12:00:00',97);
--提交事务。 
COMMIT;
```

```
--向表training插入记录5时，主键冲突执行update操作。 
INSERT INTO training
VALUES (12,'INFORMATION234','2018-06-20 12:00:00','2018-06-25 12:00:00','2018-06-26 12:00:00',94) 
ON DUPLICATE KEY UPDATE STAFF_ID=STAFF_ID,COURSE_NAME='INFORMATION234',COURSE_START_DATE='2018-06-20 12:00:00',
COURSE_END_DATE='2018-06-25 12:00:00', 
EXAM_DATE='2018-06-23 12:00:00',SCORE=88;
--提交事务。 
COMMIT;
```

## ROLLBACK<a name="ZH-CN_TOPIC_0000001835265629"></a>

**功能描述<a name="section14715115018115"></a>**

该语句回滚（废除）当前事务工作单元中的所有操作，并结束该事务。

**注意事项<a name="section1561165831112"></a>**

-   建议用户退出时，用COMMIT或ROLLBACK命令来显式地结束应用程序。如果没有显式地提交事务，而应用程序又非正常终止，则最后一个未提交的工作单元被回滚。
-   CREATE TABLESPACE和ALTER DATABASE两种DDL语句是不能回滚的。

**语法格式<a name="section18181831121"></a>**

```
ROLLBACK [ TO SAVEPOINT savepoint_name | PREPARED XID | TRANSACTION]
```

**参数说明<a name="section181217920128"></a>**

-   **_TO SAVEPOINT_**

    回滚到保存点。

-   **_savepoint\_name_**

    回滚点名。

-   **_PREPARED_**

    回滚两阶段事务。

-   **_XID_**

    事务标示符。

    **XID**格式：点分字符串 ，其中包括以下3部分：

    -   FORMAT ID：整型值, 有效范围：\[0, 9223372036854775807\]。
    -   GLOBAL TRANSACTION ID：BASE16格式， 长度小于等于128B。
    -   RANCH ID：BASE16格式， 长度小于等于128B。

-   **_TRANSACTION_**

    回滚事务。

**示例<a name="section1371232691211"></a>**

创建表posts，插入数据，回滚所有操作并结束事务。

```
--删除表posts。 
DROP TABLE IF EXISTS posts;
--创建表posts。 
CREATE TABLE posts(post_id CHAR(2) NOT NULL, post_name CHAR(16) NOT NULL, basic_wage INT, basic_bonus INT);
--向表posts中插入记录1。 
INSERT INTO posts(post_id,post_name,basic_wage,basic_bonus) VALUES('A','general manager',50000,5000); 
--向表posts中插入记录2。 
INSERT INTO posts(post_id,post_name,basic_wage,basic_bonus) VALUES('B','project manager',10000,5000); 
--向表posts中插入记录3。 
INSERT INTO posts(post_id,post_name,basic_wage,basic_bonus) VALUES('C','staff',3000,1000); 
--回滚事务。 
ROLLBACK;
```

## SELECT<a name="ZH-CN_TOPIC_0000001788466456"></a>

**功能描述<a name="section14715115018115"></a>**

从表或视图中检索行。

**注意事项<a name="section1561165831112"></a>**

-   如果访问其他用户的表，执行该语句的用户需要有READ ANY TABLE或SELECT ANY TABLE系统权限，或者表的READ或SELECT对象权限。
-   SELECT语句中出现子查询，如果子查询中引用到父查询的字段，那么父查询不支持GROUP BY子句。例如：SELECT a,b, \(SELECT t2.c FROM t2 WHERE t2.a=t1.a\) FROM t1 GROUP BY a,b；
-   对于使用了UNION、MINUS之类的集合操作语句，如果要对语句中的子SELECT语句应用ORDER BY子句或LIMIT子句，必须将该子SELECT语句，连同ORDER BY子句或LIMIT子句一同包在一层括号中。对于UNION、MINUS、INTERSECT、 EXCEPT的混合使用，优先级顺序是从左向右的。

**语法格式<a name="section18181831121"></a>**

```
SELECT [hint_info] [SQL_CALC_FOUND_ROWS] [ DISTINCT ] expression
[ [ AS ] name ] } [ , ... ]
[ FROM { table_reference [ AS OF {SCN(scn_number) | TIMESTAMP(date)} ] [ [AS] alias ] } [ , ... ] ] [{ PIVOT(aggrregte_function [[as] alias] [,...]
FOR { column | (column[,...])} IN ( {expr | (expr[,...])} [[as] alias] [,…]))
| UNPIVOT [{ INCLUDE | EXCLUDE } NULLS ] ({column1 | (column1[,...])} for {column2 | (column2[,...])} in ({column | (column[,...])} [as {alias|(alias[,…])} ] [,…] ) )
}]
[ WHERE { condition | [ NOT ] EXISTS ( correlated subquery ) } ]
[ [START WITH condition ] CONNECT BY [ NOCYCLE ] [ PRIOR ] condition ] [ GROUP BY { { column_name | expression } [ , ... ]
| { ROLLUP | CUBE }(column_name [, ... ])
| GROUPING SETS(groupingSetList)
}
]
[ HAVING condition [ , ... ] ]
[ { UNION [ ALL ] | MINUS | INTERSECT [ALL | DISTINCT] | EXCEPT [ALL | DISTINCT]} select ]
[ ORDER [SIBLINGS] BY { column_name | number | expression } [ ASC | DESC ][ NULLS FIRST | NULLS LAST ] [ , ... ] ]
[ LIMIT [ start, ] count | LIMIT count OFFSET start | OFFSET start[ LIMIT count ] ] [ FOR UPDATE [ OF col_list ] [ { WAIT sec | NOWAIT| SKIP LOCKED } ] ]
{/*+ { hash_buckect_hint \ access_method_hint | join_order_hint | join_method_hint |
pullup_subquery_hint | parallel_hint | optimization_hint }[...] */}
```

-   _hint\_info_子句：

    ```
    {/*+ { hash_buckect_hint \ access_method_hint | join_order_hint | join_method_hint |
    pullup_subquery_hint | parallel_hint | optimization_hint }[...] */}
    ```

    -   _hash\_buckect\_hint _子句：

        ```
        { HASH_BUCKECT_SIZE(size)}
        ```

    -   _access\_method\_hint_子句：

        ```
        { FULL(table_name [...])
        | INDEX(table_name index_name[...])
        | NO_INDEX(table_name index_name[...])
        | INDEX_ASC(table_name index_name[...])
        | INDEX_DESC(table_name index_name[...])
        | INDEX_FFS(table_name index_name[...])
        | NO_INDEX_FFS(table_name index_name[...])
        }
        ```

    -   _join\_order\_hint_子句：

        ```
        { ORDERED
        | LEADING(table_name[...])
        }
        ```

    -   _join\_method\_hint_子句：

        ```
        { USE_NL(table_name[...])
        | USE_MERGE(table_name[...])
        | USE_HASH(table_name[...])
        }
        ```

    -   _pullup\_subquery\_hint _子句：

        ```
        { MERGE
        | NO_MERGE
        }
        ```

    -   _parallel\_hint_子句：

        ```
        { parallel(degree)
        }
        ```

    -   _optimization\_hint_子句：

        ```
        { NO_OR_EXPAND | MATERIALIZE | INLINE
        }
        ```

-   _table\_reference _子句：

    ```
    {  [ schema_name. ]table_name [partition(partition_name)][ [AS] alias ]
    | [ schema_name. ]view_name [ [AS] alias]
    | ( select query ) [ [AS] alias ]
    | join_table
    }
    ```

    -   _join\_table__ _子句：

        默认为INNER JOIN。

        选择INNER的时候，后面的ON条件可以省略。选择CROSS JOIN时，不需要 ON条件，效果和逗号分隔的关联相同。

        ```
        table_reference [LEFT [OUTER] | RIGHT [OUTER] | FULL [OUTER] | INNER ] JOIN
        table_reference ON conditional_expr table_reference CROSS JOIN table_reference
        ```

-   外连接操作符\(+\)

    外连接不仅可以使用LEFT/RIGHT关键字来描述，也可以使用外连接操作符\(+\)来表示。WHERE子句中含有\(+\)的条件属于外连接的关联条件，其中含有\(+\)一侧的表属于左连接的右节点，不含\(+\)一侧的表属于左连接的左节点。

    外连接操作符的支持范围或约束条件如下：

    -   存在join关键字时，不可以再出现\(+\)；
    -   \(+\)前面仅可以修饰表字段；
    -   \(+\)仅支持出现在where子句中，且含\(+\)的条件不隶属OR字句；
    -   \(+\)的compare条件仅支持种运算符：=、<\>、\>、<、\>=、<=；
    -   \(+\)仅可以出现在compare条件的一侧；
    -   若该compare条件的一侧出现\(+\)，则该compare条件的每一侧最多允许存在一张表的字段；
    -   compare条件的一侧只要出现一个\(+\)，外连接操作符就生效。如果出现多个\(+\)，与出现一个\(+\)的效果相同；
    -   当多个条件同时带\(+\)时，可能会生成不了关联关系而报错（例如，t1.f1=t2.f1\(+\) and t1.f1\(+\)=t2.f1）；

-   _condition__ _子句：

    ```
    { predicate } [ { AND | OR } condition ] [...]
    ```

    _predicate _子句：

    ```
    { expression { = | <> | != | > | >= | < | <= } { ALL | ANY | SOME } expression | ( select )
    | string_expression [ NOT ] LIKE string_expression
    | expression [ NOT ] BETWEEN expression AND expression
    | expression IS [ NOT ] NULL
    | ( select | expression [,...n] ) [ NOT ] IN ( select | expression [ , ... n ] )
    | [ NOT ] EXISTS ( select )
    | expression [ NOT ] REGEXP pattern
    | [ NOT ] REGEXP_LIKE（ expression, pattern [,match_param] ）
    }
    ```

-   _groupingSetList _子句：

    聚集集合子句可以是简单表达式，一组逗号分隔的表达式列表，CUBE、ROLLUP表达式，也可以使用\(\)表示一个空分组。需要注意的是：不支持嵌套分组。

    -   多个分组组成的集合，例如：

        ```
        GROUP BY GROUPING SETS(a, (b), (c, d), ()) 
        ```

    -   在同一个查询当中也可以出现多个分组集：

        ```
        GROUP BY a, GROUPING SETS(b, c), GROUPING SETS((d, e))
        ```

    -   等价于：

        ```
        GROUP BY GROUPING SETS((a, b, d, e), (a, c, d, e))
        ```

**参数说明<a name="section181217920128"></a>**

-   **_hint\_info_**

    _hint\_info_是SQL语句中的特殊注释，用于将指令传递给数据库优化器。优化器使用这些提示为SQL语句选择执行计划，除非存在阻止优化器这样做的某些条件。

    请谨慎使用hint\_info。建议在收集了相关表的统计信息，并且通过EXPLAIN PLAN评估过不带hint\_info的优化器执行计划后，使用hint\_info。在后续版本中的数据库条件变化及查询性能增强，都会对hint\_info所起的作用产生影响。如果决定使用提示，需要注意任何使用提示所产生的短期利益不一定会产生长期改善。

    在同一个hint\_info中，使用_**access\_method\_hint**_，_**join\_order\_hint**_，_**join\_method\_hint**_  时，不能产生二义性，否则会不生效；使用  _**hash\_buckect\_hint，**_**_parallel\_hint_**时，以最后一个为准；_**optimization\_hint**_没有限制，只要存在就生效。

    -   **_hash\_buckect\_hint_**
        -   **_HASH\_BUCKECT\_SIZE\(size\)_**

            设置hash桶的大小，size为整数，仅支持hash group和hash distinct。

    -   **_access\_method\_hint_**
        -   **FULL\(_table\_name _\[...\]\)**

            全表扫描。

        -   **INDEX\(_table\_name _index\_name\[...\]\)**

            索引扫描。

        -   **NO\_INDEX\(_table\_name _index\_name\[...\]\)**

            非索引扫描。

        -   **INDEX\_ASC\(_table\_name _index\_name\[...\]\)**

            按照正向顺序的索引扫描。

        -   **INDEX\_DESC\(_table\_name _index\_name\[...\]\)**

            按照反向顺序的索引扫描。

        -   **INDEX\_FFS\(_table\_name _index\_name\[...\]\)**

            快速索引扫描。

        -   **NO\_INDEX\_FFS\(_table\_name _index\_name\[...\]\)**

            非快速索引扫描。

    -   **_join\_order\_hint_**
        -   **ORDERED**

            按照查询语句中的表的先后顺序来连接。

        -   **LEADING\(_table\_name_\[...\]\)**

            按照指定顺序来连接。

    -   **_parallel\_hint_**
        -   **parallel\(_degree_\)**

            _parallel\_hint _目前只支持单表全表扫描，支持聚集函数并行、ORDER BY并行、GROUP BY并行、UNION ALL并行、INNER JOIN连接查询并行及单表扫描返回大量结果集并行。

            -   degree

                并行度，整数类型。

                当取值范围为\[1,16\]时，_degree_值即为并发的线程数。当取值大于16时，并发的线程数等于16。

    -   **_optimization\_hint_**
        -   **NO\_OR\_EXPAND**

            指定查询语句不进行or条件转union优化。

        -   **MATERIALIZE**

            物化WITH AS子查询结果集。

        -   **INLINE**

            不物化WITH AS子查询结果集。

    -   **join\_method\_hint**
        -   **USE\_NL\(_table\_name_\[...\]\)**

            按照NESTED LOOPS方式扫描表。

        -   **USE\_MERGE\(_table\_name_\[_..._\]\)**

            按照MERGE JOIN方式扫描表，当前不支持外连接。

        -   **USE\_HASH\(_table\_name_\[...\]\)**

            按照HASH JOIN方式扫描表。

-   **_SQL\_CALC\_FOUND\_ROWS_**

    保留字。用于标识该SQL语句是否需要在执行时计算非LIMIT约束的结果集行数以便让后续的FOUND\_ROWS\(\)函数查询。SQL\_CALC\_FOUND\_ROWS保留字只能指定在SELECT语句中的第一个SELECT关键字后。若该SELECT语句属于一个

    UNION / UNION ALL / MINUS语句，则必须保证只出现在第一个SELECT子集中。该保留字只有在用户使用FOUND\_ROWS\(\) 函数时才有意义。

-   **DISTINCT**

    关键字，表示查询结果集是否需要去重。

    取值范围：已存在的字段名，或字段表达式。

-   **AS OF \{SCN\(_scn\_number_\) | TIMESTAMP\(_date_\)\}**

    查询指定SCN点或者指定时间点表的内容。目前不支持查询临时表/系统视图。

    -   **AS OF**

        关键字，闪回查询的标识。

    -   **SCN\(_scn\_number_\)**

        根据表的**_scn\_numer_**，即数据库表记录scn号，闪回查询指定SCN点的结果集。

    -   **TIMESTAMP\(_date_\)**

        根据date日期，闪回查找指定时间点的结果集。date日期必须是一个过去有效的时间戳

        说明：查询时间应该小于建表时间，否则会报错。

-   **START WITH condition CONNECT BY \[ NOCYCLE \] \[ PRIOR \] condition**

    树形表数据的子查询语句。如果一个表包含树形结构的数据，可以使用本查询子句进行查询。

    -   **START WITH**

        遍历的起始条件，指定查询开始的数据行。

    -   **CONNECT BY**

        连接条件，用于指定父数据行和子数据行之间的关系，结合prior使用。

    -   **NOCYCLE**

        即使数据中存在CONNECT BY LOOP，NOCYCLE参数也会指示数据库从查询中返回行。

    -   **PRIOR**

        prior是一个一元操作符，和+、-符号具有相同优先级。prior放在等号的左边或者右边决定了检索是自下向上还是自上向下的。换句话说：prior跟父节点列parentid放在一起，就是往父结点方向遍历；prior跟子结点列subid放在一起，则往叶子结点方向遍历。

    -   **CONNECT\_BY\_ISCYCLE伪列**

        该伪列表示当前元组是否会将层次数据形成环，该伪列只有在层次查询子句中表明NOCYCLE关键字时才有意义。如果当前行有一个子行，且子行又是当前行的祖先行，CONNECT\_BY\_ISCYCLE返回1，否则返回0。

    -   **CONNECT\_BY\_ISLEAF伪列**

        如果当前行是CONNECT BY条件定义树的叶子节点，CONNECT\_BY\_ISLEAF伪列返回1，否则返回0。该信息也表明了一个给定的行是否可以进一步扩张，表现出更多的层次。

    -   **LEVEL伪列**

        层级查询返回的每一行，根节点行LEVEL伪列返回1，之后其子孙节点的 LEVEL依次递增。根节点行是倒置树的最高行。子节点行是任意非根节点行。父节点行是任意有子节点的行。叶子节点行是任何没有子节点行。 LEVEL不得超过\_MAX\_CONNECT\_BY\_LEVEL参数值，否则报错处理。

-   **expression**

    需要查询的字段或表达式。

-   **table\_reference**

    查询表、视图、子查询。

    -   **\[ PARTITION\(  _partition\_name _\) \]**

        指定表的查询分区。**_partition\_name_**为分区名称。

-   **_database\_link\_name_**

    用户已创建的数据库链接名。

-   **_condition_**

    限制查询的记录必须满足的条件。

    查询条件由表达式和操作符共同定义，支持多个条件通过AND和OR进行关联。

    Cantian引擎支持如下的条件定义方式：

    -   使用比较操作符\>， <， \>=，<=， !=，<\>， =指定的比较查询条件。
    -   使用测试运算符LIKE/NOT LIKE、BETWEEN/NOT BETWEEN、NULL/NOT

        NULL、IN/NOT IN、REGEXP/REGEXP\_LIKE、ANY/SOME指定的范围查询条件。

    -   EXISTS \(  _select _\) 指定的查询条件，要求select子查询所查询的列存在。
    -   NOT EXISTS \(  _select _\) 指定的查询条件，要求select子查询所查询的列不存在。

-   **PIVOT**

    列转行操作符。

-   **UNPIVOT**

    行转列操作符。

-   **GROUP BY**

    指定结果集用于分组的字段，不支持大对象数据类型（BLOB、CLOB、IMAGE）进行GROUP BY操作。

-   **HAVING**

    指定限制分组结果的筛选条件。

-   **ORDER BY**

    指定结果集用于排序的字段。ORDER BY 后面的_column\_name_可以是列名，也可以是别名。

-   **ORDER SIBLINGS BY**

    指定兄弟节点之间用于排序的字段。必须指定了CONNECT BY子句时才可使用。

    -   **ASC | DESC**

        指定ORDER BY排序的方向，是升序或降序排序。默认为ASC。

    -   **NULLS FIRST | NULLS LAST**

        指定ORDER BY列中NULL值的排序位置，FIRST表示将NULL值排在最前面， LAST表示将NULL值排在最后面，若不指定该选项， ASC默认为NULLS LAST， DESC默认为NULLS FIRST。

-   **FOR UPDATE**

    表示查询的结果集用于UPDATE操作，需要加锁。

    **OF  _col\_list_**

    当涉及多个表操作时，可以使用OF子句指定需要更新的列。当表中的列出现在for update of后面，该表中满足条件的记录就会被锁定，如果表中的列没有出现在for update of列表中，该表则不会被锁定。

    WAIT  _sec _| NOWAIT | SKIP LOCKED

    用于指定锁定等待模式。

    -   WAIT  _sec_：表示等待sec秒数，超过时间没有获得锁就报错返回，可避免无限期等待。
    -   NOWAIT表示不等待，如果资源被锁定就立即返回。
    -   SKIP LOCKED表示加锁之前判断记录是否已经被锁定，如果已经锁定，这跳过该记录，如果没有被锁定，就锁定该记录。

-   **_offset\_expr，count\_expr_**

    限定返回查询结果集的偏移，以及返回数量。

-   **start,count**

    _count_指定要返回的最大行数，而_start_指定在返回行之前要跳过的行数。在两者都被指定时，在开始计算要返回的_count_行之前会跳过_start_行。

-   **UNION \[ALL\]**

    表示多个SELECT查询结果集的集合运算。

-   **MINUS**

    表示对SELECT查询的结果集进行差集运算。

-   **INTERSECT \[ALL | DISTINCT\]**

    表示对SELECT查询的结果集进行交集运算。

    -   ALL

        对结果集不进行去重操作。

    -   DISTINCT

        对结果集进行去重操作。

-   **EXCEPT \[ALL | DISTINCT\]**

    表示对SELECT查询的结果集进行差集运算。

    -   ALL

        对结果集不进行去重操作。

    -   DISTINCT

        对结果集进行去重操作。

-   **_join\_table_**

    用于关联查询的一组表集合。

    -   \[INNER\] JOIN 用于取两表的交集，此时可以省略后面的ON条件。
    -   LEFT \[OUTER\] JOIN 用于取左表的全集，右表不匹配的以null值代替。
    -   RIGHT \[OUTER\] JOIN 用于取右表的全集，左表不匹配的以null值代替。
    -   FULL \[OUTER\] JOIN 用于取两表的并集。作用和OUTER JOIN相同。

-   **\{_predicate _\} \[ \{ AND | OR \}  _condition_\]**

    指定查询结果集需要满足的条件集。

    -   AND

        两边条件同时满足。

    -   OR

        两边条件满足其一。

-   **_predicate_**子句

    指定查询结果集需要满足的条件。

    -   _pattern_是进行匹配的正则表达式，待正则处理的_expression_支持STRING类型和NUMBER类型。
    -   _match\_param_表示模式，默认为'c'。
        -   'i'表示不区分大小写进行检索。
        -   'c'表示区分大小写进行检索。

**示例<a name="section1371232691211"></a>**

-   联合查询表education和表training\_beijing\_branch。

    ```
    --删除表education。
    DROP TABLE IF EXISTS education;
    --创建表education。
    CREATE TABLE education(staff_id INT, highest_degree CHAR(8) NOT NULL, graduate_school VARCHAR(64), graduate_date DATETIME, education_note VARCHAR(70));
    --向表education中插入记录1。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(10,'doctor','Xidian University','2017-07-06 12:00:00','211'); 
    --向表education中插入记录2。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(11,'master','Northwestern Polytechnical University','2017-07-06 12:00:00','211&985'); 
    --向表education中插入记录3。 
    INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(12,'scholar','Peking University','2017-07-06 12:00:00','211&985'); 
    --提交事务。
    COMMIT;
    --删除表training_beijing_branch。
    DROP TABLE IF EXISTS training_beijing_branch;
    --创建表training_beijing_branch。
    CREATE TABLE training_beijing_branch(staff_id INT NOT NULL, staff_name VARCHAR(16), course_name VARCHAR(60), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT);
    --向表training_beijing_branch中插入记录1。
    INSERT INTO training_beijing_branch(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score) 
    VALUES(10,'liming','the tenth phase of SQL majorization','2017-06-15 12:00:00',
    '2017-06-20 12:00:00','2017-06-25 12:00:00',90);
    --向表training_beijing_branch中插入记录2。
    INSERT INTO training_beijing_branch(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score) 
    VALUES(11,'caoxueying','the tenth phase of information safety','2017-06-20 12:00:00','2017-06-25 12:00:00','2017-06-26 12:00:00',95);
    --向表training_beijing_branch中插入记录3。
    INSERT INTO training_beijing_branch(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score) 
    VALUES(13,'zhangjianmin','the tenth phase of mastering all kinds of thinking methonds','2017-07-15 12:00:00','2017-07-20 12:00:00','2017-07-25 12:00:00',97);
    --向表training_beijing_branch中插入记录4。
    INSERT INTO training_beijing_branch(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score)
    VALUES(14,'wangkangmei','quality standard','2017-06-20 12:00:00','2017-06-25 12:00:00','2017-06-26 12:00:00',98);
    --提交事务。
    COMMIT;
    --联合查询表education和表training_beijing_branch。
    SELECT education.staff_id, staff_name, highest_degree, course_name, score FROM education JOIN training_beijing_branch ON education.staff_id=training_beijing_branch.staff_id;
    --hint使用示例。
    create unique index idx_edu_gra_school on education(graduate_school);
    --指定按照索引idx_edu_gra_school的方式访问表education。
    select /*+ index(t idx_edu_gra_school) this is a hint */ * from education t;
    --指定t1和t2的连接关系为merge_sort，且指定t2为驱动表。
    select /*+ leading(t2 t1) use_merge (t1) */ t1.staff_id , t2.staff_id from education t1, training_beijing_branch t2 where t1.staff_id= t2.staff_id ;
    --删除表par_test_t1。
    drop table if exists par_test_t1;
    --创建表par_test_t1。
    create table par_test_t1(f1 int, f2 real, f3 number, f4 char(30));
    --向表par_test_t1插入记录。
    insert into par_test_t1 values(1, 15, 28, 'abcd');
    insert into par_test_t1 values(2, 16, 29, '16');
    insert into par_test_t1 values(7, 26, 39, '26');
    insert into par_test_t1 values(8, 36, 49, '36');
    insert into par_test_t1 select * from par_test_t1;
    insert into par_test_t1 select * from par_test_t1;
    insert into par_test_t1 select * from par_test_t1;
    insert into par_test_t1 select * from par_test_t1;
    insert into par_test_t1 select * from par_test_t1;
    --提交事务。
    commit;
    --SQL Parser阶段解析parallel hint并行度是4或者8，SQL执行阶段判断满足并行执行条件情况下开启4或者8个线程并行执行。
    select /*+ parallel(8) */ count(*) from par_test_t1;
    select /*+ parallel(4) */ count(*) from par_test_t1;
    ```

-   使用ORDER SIBLINGS BY排序。

    ```
    --删除表t_sibling_order。
    DROP TABLE if exists t_sibling_order;
    --创建表t_sibling_order。
    create table t_sibling_order(EMPNO NUMBER(10) NOT NULL,ENAME VARCHAR2(10),MGR NUMBER(4));
    --向表t_sibling_order中插入记录。
    insert into t_sibling_order values (1,'M',NULL);
    insert into t_sibling_order values (2,'N',NULL);
    insert into t_sibling_order values (3,'A',NULL);
    insert into t_sibling_order values (4,'C',3);
    insert into t_sibling_order values (5,'B',3);
    insert into t_sibling_order values (6,'F',4);
    insert into t_sibling_order values (7,'E',4);
    insert into t_sibling_order values (8,'D',5);
    insert into t_sibling_order values (9,'G',5);
    ---使用ORDER SIBLINGS BY排序查询。
    SELECT LEVEL, t.empno, t.ename FROM t_sibling_order t START WITH t.mgr IS NULL CONNECT BY PRIOR t.empno = t.mgr ORDER SIBLINGS BY t.ename;
    --ORDER BY使用别名排序查询。
    SELECT LEVEL, t.empno as empno, t.ename as name FROM t_sibling_order t START WITH t.mgr IS NULL CONNECT BY PRIOR t.empno = t.mgr ORDER BY name;
    ```

-   使用FOR UPDATE锁定表。

    ```
    --删除表T_UPDATE，S_UPDATE。
    DROP TABLE IF EXISTS T_UPDATE;
    DROP TABLE IF EXISTS S_UPDATE;
    --创建表T_UPDATE，S_UPDATE。
    CREATE TABLE T_UPDATE(a varchar(20), b varchar(20));
    CREATE TABLE S_UPDATE(a varchar(20), b varchar(20));
    --插入记录。
    INSERT INTO T_UPDATE VALUES('1','1');
    INSERT INTO T_UPDATE VALUES('2','2');
    INSERT INTO S_UPDATE VALUES('1','2');
    INSERT INTO S_UPDATE VALUES('2','1');
    --使用FOR UPDATE锁定表T_UPDATE。
    SELECT T_UPDATE.a, S_UPDATE.b FROM T_UPDATE JOIN S_UPDATE  ON T_UPDATE.a = S_UPDATE.a WHERE T_UPDATE.a=1 FOR UPDATE OF T_UPDATE.a;
    --切换其他SESSION后使用FOR UPDATE NOWAIT会报错，T_UPDATE.a=1记录被锁定。
    SELECT * FROM T_UPDATE WHERE T_UPDATE.a=1 FOR UPDATE NOWAIT;
    --切换其他SESSION后执行示例，S_UPDATE 未被锁定。
    SELECT * FROM S_UPDATE  for update nowait;
    ```

-   使用EXPECT、INTERSECT对结果集进行运算。

    ```
    --删除表。
    DROP TABLE IF EXISTS T_MINUS_1;
    DROP TABLE IF EXISTS T_MINUS_2;
    --创建表。
    CREATE TABLE T_MINUS_1(F_INT1 INT, F_INT2 INT);
    CREATE TABLE T_MINUS_2(F_INT1 INT, F_INT2 INT);
    --插入数据。
    INSERT INTO T_MINUS_1 VALUES(1, 11);
    INSERT INTO T_MINUS_1 VALUES(3, 332);
    INSERT INTO T_MINUS_1 VALUES(1, 11);
    INSERT INTO T_MINUS_1 VALUES(3, 33);
    INSERT INTO T_MINUS_1 VALUES(2, 22);
    INSERT INTO T_MINUS_1 VALUES(3, 33);
    INSERT INTO T_MINUS_1 VALUES(1, 11);
    INSERT INTO T_MINUS_1 VALUES(5, 55);
    INSERT INTO T_MINUS_2 VALUES(2, 22);
    INSERT INTO T_MINUS_2 VALUES(4, 44);
    INSERT INTO T_MINUS_2 VALUES(2, 22);
    INSERT INTO T_MINUS_2 VALUES(4, 44);
    INSERT INTO T_MINUS_2 VALUES(5, 54);
    INSERT INTO T_MINUS_2 VALUES(5, 55);
    INSERT INTO T_MINUS_2 VALUES(6, 66);
    INSERT INTO T_MINUS_1 VALUES(2, 22);
    INSERT INTO T_MINUS_2 VALUES(2, 22);
    COMMIT;
    --使用EXPECT进行差集运算。
    SELECT F_INT1, F_INT2 FROM T_MINUS_1 EXCEPT SELECT F_INT1, F_INT2 FROM T_MINUS_2;
    F_INT1       F_INT2
    ------------ ------------
    1            11
    3            33
    3            332
    3 rows fetched.
    SELECT F_INT1, F_INT2 FROM T_MINUS_1 EXCEPT ALL SELECT F_INT1, F_INT2 FROM T_MINUS_2 ORDER BY F_INT1 DESC, F_INT2;
    F_INT1       F_INT2
    ------------ ------------
    3            33
    3            33
    3            332
    1            11
    1            11
    1            11
    6 rows fetched.
    --使用INTERSECT进行交集运算。
    SELECT F_INT1, F_INT2 FROM T_MINUS_1 INTERSECT SELECT F_INT1, F_INT2 FROM T_MINUS_2;
    F_INT1       F_INT2
    ------------ ------------
    2            22
    5            55
    2 rows fetched.
    SELECT F_INT1, F_INT2 FROM T_MINUS_1 INTERSECT ALL SELECT F_INT1, F_INT2 FROM T_MINUS_2 ORDER BY F_INT1 DESC, F_INT2;
    F_INT1       F_INT2
    ------------ ------------
    5            55
    2            22
    2            22
    3 rows fetched.
    ```

## TRUNCATE TABLE<a name="ZH-CN_TOPIC_0000001788626060"></a>

**功能描述<a name="section297214454515"></a>**

删除表中所有的数据，释放表的存储空间。

**注意事项<a name="section1037811158457"></a>**

-   用户可通过TRUNCATE TABLE语句删除表中所有的行。用户能清空自己表中的行；清空其他用户的表，需要DROP ANY TABLE权限。
-   TRUNCATE语句不能回滚。
-   可以使用DELETE语句删除数据。
-   数据库重启回滚期间不支持该操作。

**语法格式<a name="section471462084518"></a>**

```
TRUNCATE TABLE [ schema_name. ]table_name [ PURGE ] [ { DROP | REUSE } STORAGE ]
```

**参数说明<a name="section8218102814511"></a>**

-   **\[_schema\_name._\]  _table\_name_**

    清空表名。

-   **不指定PURGE、DROP STORAGE、REUSE STORAGE**

    对表执行TRUNCATE操作后，表会放入回收站，可以通过FLASHBACK命令恢复。

-   **PURGE**

    和DROP STORAGE等价。

-   **DROP STORAGE**

    DROP STORAGE是默认值，回收清除表中rows的free space给tablespace，回收回来的free space可以供其它segment使用。

-   **REUSE STORAGE**

    不回收清除表中rows的free space给tablespace，这部分空间只能被自己用。

**示例<a name="section199993419452"></a>**

删除表education的全部数据并回收清除表中记录的空闲空间。

```
--删除表education。
DROP TABLE IF EXISTS education;
```

```
--创建表education。
CREATE TABLE education(staff_id INT, highest_degree CHAR(8) NOT NULL, graduate_school VARCHAR(64), graduate_date DATETIME, education_note VARCHAR(70));
```

```
--向表education中插入记录1。
INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(10,'doctor','Xidian University','2017-07-06 12:00:00','211');
--向表education中插入记录2。
INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(11,'master','Northwestern Polytechnical University','2017-07-06 12:00:00','211&985');
--向表education中插入记录3。
INSERT INTO education(staff_id,highest_degree,graduate_school,graduate_date,education_note) VALUES(12,'scholar','Xian University of Architecture and Technology','2017-07-06 12:00:00','not 211 or 985');
--提交整个事务。 
COMMIT;
```

--删除表education的全部数据并回收清除表中记录的空闲空间。

```
TRUNCATE TABLE education DROP STORAGE;
```

## UPDATE<a name="ZH-CN_TOPIC_0000001788466404"></a>

**功能描述<a name="section676512164912"></a>**

更新表中行的值。

**注意事项<a name="section1086772612497"></a>**

-   UPDATE事务提交是默认关闭的。会话退出时，需要显式COMMIT，否则记录将丢失。
-   执行该语句的用户需要有表的UPDATE权限或者UPDATE ANY TABLE的系统权限。普通用户不允许update系统SYS用户对象。
-   不支持临时表的多表更新。
-   当发生行锁冲突的行数据发生跨分区更新时，等待行锁的后续事务可能更新不到此数据行。

**语法格式<a name="section1543663314910"></a>**

只有在使用_join\_table_子句时支持使用\(_col\_name_\[,...\]\) = \(_expression_\[,...\]\) 。

```
UPDATE table_reference SET { [col_name = expression] [ , ... ] | (col_name[,...]) = (SELECT expression[,...]) } [ WHERE condition ]
```

-   _table\_reference _子句：

    ```
    { [ schema_name. ] table_name
    | join_table
    }
    ```

-   _join\_table _子句：

    ```
    table_reference [LEFT [OUTER] | RIGHT [OUTER] | INNER ] JOIN table_reference ON conditional_expr 
    ```

**参数说明<a name="section889953784917"></a>**

-   _**table\_reference**_

    要更新的表、表集合。

    取值范围：已存在的表、表集合。

-   **_table\_name_**

    要更新的表名。

    取值范围：已存在的表名称。

-   **_col\_name_**

    要修改的字段名。

    取值范围：已存在的字段名。

-   **_expression_**

    赋给字段的值或表达式。

-   **_condition_**

    一个返回布尔类型结果的表达式。只有这个表达式返回true的行才会被更新。

-   **_join\_table_**

    用于关联查询的一组表集合。

    -   \[INNER\] JOIN 用于取两表的交集。
    -   LEFT \[OUTER\] JOIN 用于取左表的全集，右表不匹配的以null值代替。
    -   RIGHT \[OUTER\] JOIN 用于取右表的全集，左表不匹配的以null值代替。

**示例<a name="section4708194513495"></a>**

更新表training中ID和表education中staff\_id相同的记录，修改first\_name为其他值。

```
--删除表education、training。 
DROP TABLE IF EXISTS education; 
DROP TABLE IF EXISTS training;
```

```
--创建表education、training。
CREATE TABLE education(staff_id INT, first_name VARCHAR(20));
CREATE TABLE training(staff_id INT, first_name VARCHAR(20));
```

```
--插入记录。
INSERT INTO education VALUES(1, 'ALICE');
INSERT INTO education VALUES(2, 'BROWN'); 
INSERT INTO training VALUES(1, 'ALICE'); 
INSERT INTO training VALUES(1, 'ALICE'); 
INSERT INTO training VALUES(1, 'ALICE'); 
INSERT INTO training VALUES(3, 'BOB');
```

```
--更新表training中staff_id和表education中staff_id相同的记录的first_name字段。
UPDATE training INNER JOIN education ON training.staff_id = education.staff_id SET training.first_name = 'ALAN';
```

更新表training\_beijing\_branch中staff\_id为10的记录。

```
--删除表training_beijing_branch。
DROP TABLE IF EXISTS training_beijing_branch;
```

```
--创建表training_beijing_branch。
CREATE TABLE training_beijing_branch(staff_id INT NOT NULL, staff_name VARCHAR(16), course_name VARCHAR(50), course_start_date DATETIME, course_end_date DATETIME, exam_date DATETIME, score INT);
```

```
--向表training_beijing_branch中插入记录1。
INSERT INTO training_beijing_branch(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score)
VALUES(10,'liming','the tenth phase of SQL majorization','2017-06-15 12:00:00','2017-06-20 12:00:00','2017-06-25 12:00:00',90);
--向表training_beijing_branch中插入记录2。
INSERT INTO training_beijing_branch(staff_id,staff_name,course_name,course_start_date,course_end_date,exam_date,score)
VALUES(11,'caoxueying','the tenth phase of information safety','2017-06-20 12:00:00','2017-06-25 12:00:00','2017-06-26 12:00:00',95);
--提交整个事务。 
COMMIT;
```

```
--更新表training_beijing_branch的数据。
UPDATE training_beijing_branch SET staff_name='caoxueying', course_name='the twenty-third phase of information safety' WHERE staff_id=10;
--提交事务。 
COMMIT;
```

更新分区表student\_score的分区键score，将其中一条记录从一个分区更新到另外一个分区。

```
--删除表student_score。
DROP TABLE IF EXISTS student_score;
```

```
--创建分区表student_score。
CREATE TABLE student_score(id INT NOT NULL, score INT) PARTITION BY RANGE(score)
(
PARTITION P1 VALUES LESS THAN(60), 
PARTITION P2 VALUES LESS THAN(100)
);
```

```
--向表student_score中插入记录1。
INSERT INTO student_score(id, score) VALUES(20180102, 50);
--向表student_score中插入记录2。
INSERT INTO student_score(id, score) VALUES(20180121, 80);
```

```
--更新表student_score中的记录1。
UPDATE student_score SET score=70 WHERE id =20180102;
--提交事务。 
COMMIT;
```

